import { Comparable, Comparison, } from "@siteimprove/alfa-comparable";
import { Equatable } from "@siteimprove/alfa-equatable";
import { Serializable } from "@siteimprove/alfa-json";
import { Option, None } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Refinement } from "@siteimprove/alfa-refinement";
const { not } = Predicate;
const { isObject } = Refinement;
const { compareComparable } = Comparable;
/**
 * @public
 */
export var Iterable;
(function (Iterable) {
    function isIterable(value) {
        return isObject(value) && Symbol.iterator in value;
    }
    Iterable.isIterable = isIterable;
    function* empty() { }
    Iterable.empty = empty;
    function* from(arrayLike) {
        for (let i = 0, n = arrayLike.length; i < n; i++) {
            yield arrayLike[i];
        }
    }
    Iterable.from = from;
    function size(iterable) {
        return reduce(iterable, (size) => size + 1, 0);
    }
    Iterable.size = size;
    function isEmpty(iterable) {
        for (const _ of iterable) {
            return false;
        }
        return true;
    }
    Iterable.isEmpty = isEmpty;
    function forEach(iterable, callback) {
        let index = 0;
        for (const value of iterable) {
            callback(value, index++);
        }
    }
    Iterable.forEach = forEach;
    function* map(iterable, mapper) {
        let index = 0;
        for (const value of iterable) {
            yield mapper(value, index++);
        }
    }
    Iterable.map = map;
    function* flatMap(iterable, mapper) {
        let index = 0;
        for (const value of iterable) {
            yield* mapper(value, index++);
        }
    }
    Iterable.flatMap = flatMap;
    function* flatten(iterable) {
        for (const value of iterable) {
            yield* value;
        }
    }
    Iterable.flatten = flatten;
    function reduce(iterable, reducer, accumulator) {
        let index = 0;
        for (const value of iterable) {
            accumulator = reducer(accumulator, value, index++);
        }
        return accumulator;
    }
    Iterable.reduce = reduce;
    function reduceWhile(iterable, predicate, reducer, accumulator) {
        let index = 0;
        for (const value of iterable) {
            if (predicate(value, index)) {
                accumulator = reducer(accumulator, value, index++);
            }
            else {
                break;
            }
        }
        return accumulator;
    }
    Iterable.reduceWhile = reduceWhile;
    function reduceUntil(iterable, predicate, reducer, accumulator) {
        return reduceWhile(iterable, not(predicate), reducer, accumulator);
    }
    Iterable.reduceUntil = reduceUntil;
    function apply(iterable, mapper) {
        return flatMap(mapper, (mapper) => map(iterable, mapper));
    }
    Iterable.apply = apply;
    function* filter(iterable, predicate) {
        let index = 0;
        for (const value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
        }
    }
    Iterable.filter = filter;
    function reject(iterable, predicate) {
        return filter(iterable, not(predicate));
    }
    Iterable.reject = reject;
    function find(iterable, predicate) {
        let index = 0;
        for (const value of iterable) {
            if (predicate(value, index++)) {
                return Option.of(value);
            }
        }
        return None;
    }
    Iterable.find = find;
    function findLast(iterable, predicate) {
        let index = 0;
        let result = None;
        for (const value of iterable) {
            if (predicate(value, index++)) {
                result = Option.of(value);
            }
        }
        return result;
    }
    Iterable.findLast = findLast;
    function includes(iterable, value) {
        return some(iterable, Predicate.equals(value));
    }
    Iterable.includes = includes;
    function collect(iterable, mapper) {
        return flatMap(iterable, mapper);
    }
    Iterable.collect = collect;
    function collectFirst(iterable, mapper) {
        return first(collect(iterable, mapper));
    }
    Iterable.collectFirst = collectFirst;
    function some(iterable, predicate) {
        let index = 0;
        for (const value of iterable) {
            if (predicate(value, index++)) {
                return true;
            }
        }
        return false;
    }
    Iterable.some = some;
    function none(iterable, predicate) {
        return every(iterable, not(predicate));
    }
    Iterable.none = none;
    function every(iterable, predicate) {
        let index = 0;
        for (const value of iterable) {
            if (!predicate(value, index++)) {
                return false;
            }
        }
        return true;
    }
    Iterable.every = every;
    function count(iterable, predicate) {
        return reduce(iterable, (count, value, index) => (predicate(value, index) ? count + 1 : count), 0);
    }
    Iterable.count = count;
    function* distinct(iterable) {
        const seen = [];
        for (const value of iterable) {
            if (seen.some(Predicate.equals(value))) {
                continue;
            }
            seen.push(value);
            yield value;
        }
    }
    Iterable.distinct = distinct;
    function get(iterable, index) {
        return index < 0 ? None : first(skip(iterable, index));
    }
    Iterable.get = get;
    function has(iterable, index) {
        return index < 0 ? false : !isEmpty(skip(iterable, index));
    }
    Iterable.has = has;
    function* set(iterable, index, value) {
        const it = iterator(iterable);
        while (index-- > 0) {
            const next = it.next();
            if (next.done === true) {
                return;
            }
            yield next.value;
        }
        const next = it.next();
        if (next.done === true) {
            return;
        }
        yield value;
        while (true) {
            const next = it.next();
            if (next.done === true) {
                return;
            }
            yield next.value;
        }
    }
    Iterable.set = set;
    function* insert(iterable, index, value) {
        const it = iterator(iterable);
        while (index-- > 0) {
            const next = it.next();
            if (next.done === true) {
                return;
            }
            yield next.value;
        }
        yield value;
        while (true) {
            const next = it.next();
            if (next.done === true) {
                return;
            }
            yield next.value;
        }
    }
    Iterable.insert = insert;
    function* append(iterable, value) {
        yield* iterable;
        yield value;
    }
    Iterable.append = append;
    function* prepend(iterable, value) {
        yield value;
        yield* iterable;
    }
    Iterable.prepend = prepend;
    function* concat(iterable, ...iterables) {
        yield* iterable;
        for (const iterable of iterables) {
            yield* iterable;
        }
    }
    Iterable.concat = concat;
    function subtract(iterable, ...iterables) {
        return reject(iterable, (value) => includes(flatten(iterables), value));
    }
    Iterable.subtract = subtract;
    function intersect(iterable, ...iterables) {
        return filter(iterable, (value) => includes(flatten(iterables), value));
    }
    Iterable.intersect = intersect;
    function* zip(a, b) {
        const itA = iterator(a);
        const itB = iterator(b);
        while (true) {
            const a = itA.next();
            const b = itB.next();
            if (a.done === true || b.done === true) {
                return;
            }
            yield [a.value, b.value];
        }
    }
    Iterable.zip = zip;
    function first(iterable) {
        for (const value of iterable) {
            return Option.of(value);
        }
        return None;
    }
    Iterable.first = first;
    function last(iterable) {
        let last = null;
        for (const value of iterable) {
            last = value;
        }
        return Option.from(last);
    }
    Iterable.last = last;
    function* take(iterable, count) {
        const it = iterator(iterable);
        while (count-- > 0) {
            const next = it.next();
            if (next.done === true) {
                return;
            }
            yield next.value;
        }
    }
    Iterable.take = take;
    function* takeWhile(iterable, predicate) {
        let index = 0;
        for (const value of iterable) {
            if (predicate(value, index++)) {
                yield value;
            }
            else {
                break;
            }
        }
    }
    Iterable.takeWhile = takeWhile;
    function takeUntil(iterable, predicate) {
        return takeWhile(iterable, not(predicate));
    }
    Iterable.takeUntil = takeUntil;
    function* takeLast(iterable, count = 1) {
        if (count <= 0) {
            return;
        }
        const last = [];
        for (const value of iterable) {
            last.push(value);
            if (last.length > count) {
                last.shift();
            }
        }
        yield* last;
    }
    Iterable.takeLast = takeLast;
    function* takeLastWhile(iterable, predicate) {
        const values = [...iterable];
        let last = values.length - 1;
        while (last >= 0) {
            if (predicate(values[last], last)) {
                last--;
            }
            else {
                break;
            }
        }
        for (let i = last, n = values.length - 1; i < n; i++) {
            yield values[i];
        }
    }
    Iterable.takeLastWhile = takeLastWhile;
    function takeLastUntil(iterable, predicate) {
        return takeLastWhile(iterable, not(predicate));
    }
    Iterable.takeLastUntil = takeLastUntil;
    function* skip(iterable, count) {
        const it = iterator(iterable);
        while (count-- > 0) {
            const next = it.next();
            if (next.done === true) {
                return;
            }
        }
        while (true) {
            const next = it.next();
            if (next.done === true) {
                return;
            }
            yield next.value;
        }
    }
    Iterable.skip = skip;
    function* skipWhile(iterable, predicate) {
        let index = 0;
        let skipped = false;
        for (const value of iterable) {
            if (!skipped && predicate(value, index++)) {
                continue;
            }
            else {
                skipped = true;
                yield value;
            }
        }
    }
    Iterable.skipWhile = skipWhile;
    function skipUntil(iterable, predicate) {
        return skipWhile(iterable, not(predicate));
    }
    Iterable.skipUntil = skipUntil;
    function* skipLast(iterable, count = 1) {
        const it = iterator(iterable);
        const first = [];
        while (count-- > 0) {
            const next = it.next();
            if (next.done === true) {
                return;
            }
            first.push(next.value);
        }
        while (true) {
            const next = it.next();
            if (next.done === true) {
                return;
            }
            first.push(next.value);
            yield first.shift();
        }
    }
    Iterable.skipLast = skipLast;
    function* skipLastWhile(iterable, predicate) {
        const values = [...iterable];
        let last = values.length - 1;
        while (last >= 0) {
            if (predicate(values[last], last)) {
                last--;
            }
            else {
                break;
            }
        }
        for (let i = 0, n = last; i < n; i++) {
            yield values[i];
        }
    }
    Iterable.skipLastWhile = skipLastWhile;
    function skipLastUntil(iterable, predicate) {
        return skipLastWhile(iterable, not(predicate));
    }
    Iterable.skipLastUntil = skipLastUntil;
    function trim(iterable, predicate) {
        return trimTrailing(trimLeading(iterable, predicate), predicate);
    }
    Iterable.trim = trim;
    function trimLeading(iterable, predicate) {
        return skipWhile(iterable, predicate);
    }
    Iterable.trimLeading = trimLeading;
    function trimTrailing(iterable, predicate) {
        return skipLastWhile(iterable, predicate);
    }
    Iterable.trimTrailing = trimTrailing;
    function rest(iterable) {
        return skip(iterable, 1);
    }
    Iterable.rest = rest;
    function slice(iterable, start, end) {
        iterable = skip(iterable, start);
        if (end !== undefined) {
            iterable = take(iterable, end - start);
        }
        return iterable;
    }
    Iterable.slice = slice;
    function* reverse(iterable) {
        const array = Array.from(iterable);
        for (let i = array.length - 1; i >= 0; i--) {
            yield array[i];
        }
    }
    Iterable.reverse = reverse;
    function join(iterable, separator) {
        const it = iterator(iterable);
        let next = it.next();
        if (next.done === true) {
            return "";
        }
        let result = `${next.value}`;
        next = it.next();
        while (next.done !== true) {
            result += `${separator}${next.value}`;
            next = it.next();
        }
        return result;
    }
    Iterable.join = join;
    function sort(iterable) {
        return sortWith(iterable, compareComparable);
    }
    Iterable.sort = sort;
    function* sortWith(iterable, comparer) {
        yield* [...iterable].sort(comparer);
    }
    Iterable.sortWith = sortWith;
    function compare(a, b) {
        return compareWith(a, b, compareComparable);
    }
    Iterable.compare = compare;
    function compareWith(a, b, comparer) {
        const itA = iterator(a);
        const itB = iterator(b);
        let index = 0;
        while (true) {
            const a = itA.next();
            const b = itB.next();
            if (a.done === true) {
                return b.done === true ? Comparison.Equal : Comparison.Less;
            }
            if (b.done === true) {
                return Comparison.Greater;
            }
            const result = comparer(a.value, b.value, index++);
            if (result !== 0) {
                return result;
            }
        }
    }
    Iterable.compareWith = compareWith;
    function equals(a, b) {
        const itA = iterator(a);
        const itB = iterator(b);
        while (true) {
            const a = itA.next();
            const b = itB.next();
            if (a.done === true) {
                return b.done === true;
            }
            if (b.done === true || !Equatable.equals(a.value, b.value)) {
                return false;
            }
        }
    }
    Iterable.equals = equals;
    function hash(iterable, hash) {
        let size = 0;
        for (const value of iterable) {
            hash.writeUnknown(value);
            size++;
        }
        hash.writeUint32(size);
    }
    Iterable.hash = hash;
    function iterator(iterable) {
        return iterable[Symbol.iterator]();
    }
    Iterable.iterator = iterator;
    function groupBy(iterable, grouper) {
        const groups = [];
        let index = 0;
        for (const value of iterable) {
            const group = grouper(value, index++);
            const existing = groups.find(([existing]) => Equatable.equals(group, existing));
            if (existing === undefined) {
                groups.push([group, [value]]);
            }
            else {
                existing[1].push(value);
            }
        }
        return groups;
    }
    Iterable.groupBy = groupBy;
    function toJSON(iterable, options) {
        return [...map(iterable, (value) => Serializable.toJSON(value, options))];
    }
    Iterable.toJSON = toJSON;
})(Iterable || (Iterable = {}));
//# sourceMappingURL=iterable.js.map