import { Array } from "@siteimprove/alfa-array";
import { Cache } from "@siteimprove/alfa-cache";
import { Cascade, Origin } from "@siteimprove/alfa-cascade";
import { Keyword, Lexer, Token } from "@siteimprove/alfa-css";
import { Device } from "@siteimprove/alfa-device";
import { Document, Element, Node, Shadow, } from "@siteimprove/alfa-dom";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Map } from "@siteimprove/alfa-map";
import { None, Option } from "@siteimprove/alfa-option";
import { Result } from "@siteimprove/alfa-result";
import { Context } from "@siteimprove/alfa-selector";
import { Set } from "@siteimprove/alfa-set";
import * as element from "./element/element.js";
import { Longhands } from "./longhands.js";
import * as node from "./node/node.js";
import { Shorthands } from "./shorthands.js";
import { Value } from "./value.js";
import { Variable } from "./variable.js";
/**
 * @public
 */
export class Style {
    /**
     * Build a style from a list of declarations.
     *
     * @remarks
     * Declarations must be pre-sorted in decreasing Cascade order.
     * Prefer using Style.from(), which has fewer assumptions.
     */
    static of(styleDeclarations, device, parent = None) {
        // declarations are read twice, once for variables and once for properties,
        // so we cannot use a read-once iterable. Main use case from `Style.from`
        // is already sending an Array, so this is inexpensive
        const declarations = Array.from(styleDeclarations);
        /**
         * First pass, substitute all variables by their definition
         */
        // First step: gather all variable declarations.
        const declaredVariables = Variable.gather(declarations.map(([declaration]) => declaration));
        // Second step: since CSS variables are always inherited, and inheritance
        // takes precedence over fallback, we can merge the current variables with
        // the parent ones, this will effectively resolve variable inheritance.
        const cascadedVariables = parent
            .map((parent) => parent.variables)
            .getOr(Map.empty())
            .concat(declaredVariables);
        // Third step: pre-substitute the resolved cascading variables from above,
        // replacing any `var()` function references with their substituted tokens.
        // This effectively takes care of deleting variables with syntactically
        // invalid values, circular references, too many substitutions, …
        const variables = Variable.flatten(cascadedVariables);
        /**
         * Second pass: Resolve cascading properties using the cascading variables
         * from the first pass.
         *
         * Since declarations have been sorted in decreasing cascade order by the
         * cascade, the first value we encounter for each property is the correct
         * one for the cascaded value.
         */
        let properties = Map.empty();
        // Since we effectively only handle User-Agent and Author origins, we can
        // go for a simple version of `revert`. We don't use it in the User Agent
        // style sheet, and will simply skip all author origin declarations.
        // So, we simply keep a set of reverted properties, and skip author
        // declarations for these.
        let reverted = Set.empty();
        function registerParsed(name, value, declaration) {
            if (value.equals(Keyword.of("revert"))) {
                reverted = reverted.add(name);
            }
            else {
                properties = properties.set(name, Value.of(value, Option.of(declaration)));
            }
        }
        function register(name, value, declaration, origin, parsed) {
            // If the property has been reverted to User Agent origin,
            // discard any Author declaration.
            if (reverted.has(name) && Origin.isAuthor(origin)) {
                return;
            }
            // If the property is already set by a more specific declaration, skip.
            if (properties.get(name).isNone()) {
                // If the declaration comes from a shorthand, it is pre-parsed in a
                // Value. Otherwise, we only have the string and need to parse it
                // (avoid parsing everything before we know we'll need it).
                if (parsed) {
                    // Type is ensured by the overload.
                    return registerParsed(name, value, declaration);
                }
                else {
                    for (const result of parseLonghand(Longhands.get(name), 
                    // Type is ensured by the overload.
                    value, variables)) {
                        registerParsed(name, result, declaration);
                    }
                }
            }
        }
        for (const [declaration, origin] of declarations) {
            const { name, value } = declaration;
            if (Longhands.isName(name)) {
                register(name, value, declaration, origin, false);
            }
            else if (Shorthands.isName(name)) {
                for (const result of parseShorthand(Shorthands.get(name), value, variables)) {
                    for (const [name, value] of result) {
                        register(name, value, declaration, origin, true);
                    }
                }
            }
        }
        return new Style(device, parent, variables, properties);
    }
    static _empty = new Style(Device.standard(), None, Map.empty(), Map.empty());
    static empty() {
        return this._empty;
    }
    _device;
    _parent;
    _variables;
    _properties;
    // We cache computed properties but not specified properties as these are
    // inexpensive to resolve from cascaded and computed properties.
    _computed = Map.empty();
    constructor(device, parent, variables, properties) {
        this._device = device;
        this._parent = parent;
        this._variables = variables;
        this._properties = properties;
    }
    get device() {
        return this._device;
    }
    get parent() {
        return this._parent.getOrElse(() => Style._empty);
    }
    get variables() {
        return this._variables;
    }
    get properties() {
        return this._properties;
    }
    root() {
        return this._parent.map((parent) => parent.root()).getOr(this);
    }
    cascaded(name) {
        return this._properties.get(name);
    }
    specified(name) {
        const { options: { inherits }, } = Longhands.get(name);
        return this.cascaded(name)
            .map((cascaded) => {
            const { value, source } = cascaded;
            if (Keyword.isKeyword(value)) {
                switch (value.value) {
                    // https://drafts.csswg.org/css-cascade/#initial
                    case "initial":
                        return this.initial(name, source);
                    // https://drafts.csswg.org/css-cascade/#inherit
                    case "inherit":
                        return this.inherited(name);
                    // https://drafts.csswg.org/css-cascade/#inherit-initial
                    case "unset":
                        return inherits
                            ? this.inherited(name)
                            : this.initial(name, source);
                }
            }
            return cascaded;
        })
            .getOrElse(() => inherits
            ? this._parent
                .map((parent) => parent.computed(name))
                .getOrElse(() => this.initial(name))
            : this.initial(name));
    }
    computed(name) {
        if (this === Style._empty) {
            return this.initial(name);
        }
        if (!this._computed.has(name)) {
            // Keeping semi-useless variables to reduce the any-pollution to a single call
            const compute = Longhands.get(name).compute;
            const specified = this.specified(name);
            // Typescript is completely struggling on this one.
            // Essentially, N has to be assumed as Name at this point. TS lost the fact
            // that specified and compute refer to the same property.
            // So, it has specified of type S1 | S2 | …, and compute of type
            // S1 -> C1 | S2 -> C2 | …, but no link to the fact that the same should
            // be used in both.
            // The union of functions is exploded as (S1 & S2 & …) -> (C1 | C2 | …)
            // due to contravariance. But the Si tend to be unions, and the
            // intersection of union is expanded a bit too greedily by TS and reaches
            // its union size limit of 100,000 term (!)
            // So, we just skip type checking here…
            //
            // See https://github.com/microsoft/TypeScript/issues/53234
            const computed = compute(specified, this);
            this._computed = this._computed.set(name, computed);
        }
        return this._computed
            .get(name)
            // The previous block ensure we've set the value.
            .getUnsafe(`Computed style for ${name} does not exists`);
    }
    initial(name, source = None) {
        return Value.of(Longhands.get(name).initial, source);
    }
    inherited(name) {
        return this.parent.computed(name);
    }
    toJSON() {
        return {
            device: this._device.toJSON(),
            variables: [...this._variables].map(([name, value]) => [
                name,
                value.toJSON(),
            ]),
            properties: [...this._properties].map(([name, value]) => [
                name,
                value.toJSON(),
            ]),
        };
    }
}
/**
 * @public
 */
(function (Style) {
    const cache = Cache.empty();
    /**
     * Build the style of an element.
     *
     * @remarks
     * This gather all style declarations that apply to the element, in decreasing
     * precedence (according to cascade sort order) and delegate the rest of the
     * work to `Style.of`.
     */
    function from(element, device, context = Context.empty()) {
        return cache
            .get(device, Cache.empty)
            .get(element.freeze(), Cache.empty)
            .get(context, () => {
            const declarations = [];
            const root = element.root();
            if (Document.isDocument(root) || Shadow.isShadow(root)) {
                const cascade = Cascade.from(root, device);
                // Walk up the cascade, starting from the node associated to the
                // element, and gather all declarations met on the way.
                // The cascade has been build in decreasing precedence as we move up
                // (highest precedence rules are at the bottom), thus the declarations
                // are seen in decreasing precedence and pushed to the end of the
                // existing list which is thus also ordered in decreasing precedence.
                for (const node of cascade
                    .get(element, context)
                    .inclusiveAncestors()) {
                    declarations.push(...Iterable.reverse(Iterable.map(node.block.declarations, (declaration) => [declaration, node.block.precedence.origin])));
                }
            }
            else {
                // If the element is not part of a Document, this is likely
                // a standalone code snippet. In that case, we still want
                // to gather the `style` attribute.
                declarations.push(...element.style
                    .map((block) => Iterable.reverse(Iterable.map(block.declarations, (declaration) => [
                    declaration,
                    declaration.important
                        ? Origin.ImportantAuthor
                        : Origin.NormalAuthor,
                ])))
                    .getOr([]));
            }
            return Style.of(declarations, device, element
                .parent(Node.flatTree)
                .filter(Element.isElement)
                .map((parent) => from(parent, device, context)));
        });
    }
    Style.from = from;
    Style.getOffsetParent = element.getOffsetParent, Style.getPositioningParent = element.getPositioningParent, Style.hasBorder = element.hasBorder, Style.hasBoxShadow = element.hasBoxShadow, Style.hasCascadedStyle = element.hasCascadedStyle, Style.hasComputedStyle = element.hasComputedStyle, Style.hasPositioningParent = element.hasPositioningParent, Style.hasOutline = element.hasOutline, Style.hasSpecifiedStyle = element.hasSpecifiedStyle, Style.hasTextDecoration = element.hasTextDecoration, Style.hasTransparentBackground = element.hasTransparentBackground, Style.isFocusable = element.isFocusable, Style.isImportant = element.isImportant, Style.isInert = element.isInert, Style.isPositioned = element.isPositioned, Style.isTabbable = element.isTabbable, Style.isVisibleShadow = element.isVisibleShadow;
    Style.isRendered = node.isRendered, Style.isVisible = node.isVisible;
})(Style || (Style = {}));
function parseLonghand(property, value, variables) {
    const substitution = Variable.substitute(Lexer.lex(value), variables);
    if (!substitution.isSome()) {
        return Result.of(Keyword.of("unset"));
    }
    const [tokens, substituted] = substitution.get();
    const parse = property.parse;
    const result = parse(trim(tokens)).map(([, value]) => value);
    if (result.isErr() && substituted) {
        return Result.of(Keyword.of("unset"));
    }
    return result;
}
function parseShorthand(shorthand, value, variables) {
    const substitution = Variable.substitute(Lexer.lex(value), variables);
    // The typing are ensured by the construction of Shorthands.Longhands<N>. We should
    // nonetheless try and find a way to enforce it automatically. Probably by
    // adding the shorthand name in the typing of Shorthand.
    const longhands = shorthand.properties;
    const parse = shorthand.parse;
    if (!substitution.isSome()) {
        // If the substitution failed, the declaration is syntactically invalid,
        // and acts as unset.
        // See https://drafts.csswg.org/css-variables/#invalid-variables
        return Result.of(Iterable.map(longhands, (property) => [property, Keyword.of("unset")]));
    }
    // Perform variable substitution and parse the result.
    const [tokens, substituted] = substitution.get();
    const result = parse(trim(tokens)).map(([, value]) => {
        // If we get a single keyword (instead of an iterable of [longhand, value]),
        // it must be a global keyword, apply to all longhands.
        if (Keyword.isKeyword(value)) {
            return Iterable.map(longhands, (property) => [property, value]);
        }
        return value;
    });
    // If there is an error following a substitution, the declaration is discarded
    // and acts as unset.
    // See https://drafts.csswg.org/css-variables/#invalid-variables
    if (result.isErr() && substituted) {
        return Result.of(Iterable.map(longhands, (property) => [property, Keyword.of("unset")]));
    }
    // Otherwise (no error or no substitution), return the result (value or error).
    return result;
}
function trim(tokens) {
    return tokens.trim(Token.isWhitespace);
}
//# sourceMappingURL=style.js.map