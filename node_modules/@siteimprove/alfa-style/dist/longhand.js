import { Keyword } from "@siteimprove/alfa-css";
import * as parser from "@siteimprove/alfa-parser";
const { left, either, end } = parser.Parser;
/**
 * @internal
 *
 * @remarks
 * The parameter name SPECIFIED is somewhat ill-named. This type does not
 * contain the default keywords that are handled globally. The actual type of
 * specified values does include them.
 */
export class Longhand {
    static of(initial, parse, compute, options = {
        inherits: false,
    }) {
        return new Longhand(initial, parse, compute, options);
    }
    static extend(property, overrides = {}) {
        const { initial = property._initial, parse = property._parseBase, compute = property._compute, options = {}, } = overrides;
        return new Longhand(initial, parse, compute, {
            ...property._options,
            ...options,
        });
    }
    _initial;
    _parseBase;
    _parse;
    _compute;
    _options;
    constructor(initial, parseBase, compute, options) {
        this._initial = initial;
        this._parseBase = parseBase;
        this._parse = left(either(Longhand.parseDefaults, parseBase), end(() => "Expected end of input"));
        this._compute = compute;
        this._options = options;
    }
    get initial() {
        return this._initial;
    }
    get parse() {
        return this._parse;
    }
    /**
     * Return the base parser of the property, which does not parse the global
     * default values. This is often useful when building parsers for shorthands.
     *
     * @internal
     */
    get parseBase() {
        return this._parseBase;
    }
    get compute() {
        return this._compute;
    }
    get options() {
        return this._options;
    }
}
/**
 * @internal
 */
(function (Longhand) {
    Longhand.parseDefaults = Keyword.parse("initial", "inherit", "revert", "unset");
    /**
     * Utility function for longhands whose value can only be a list of keywords.
     *
     * @internal
     */
    function fromKeywords(options, initial, ...other) {
        return Longhand.of(Keyword.of(initial), Keyword.parse(initial, ...other), (value) => value, options);
    }
    Longhand.fromKeywords = fromKeywords;
})(Longhand || (Longhand = {}));
//# sourceMappingURL=longhand.js.map