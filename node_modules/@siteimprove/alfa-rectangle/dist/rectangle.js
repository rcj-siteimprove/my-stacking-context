const { max, min } = Math;
/**
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMRect}
 *
 * @remarks
 * The y axis in the coordinate system on the HTML canvas is inverted so that
 * the y coordinates gets bigger further down the page.
 *
 * @public
 */
export class Rectangle {
    static of(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    }
    static _empty = new Rectangle(Infinity, Infinity, 0, 0);
    static empty() {
        return this._empty;
    }
    static _full = new Rectangle(-Infinity, -Infinity, Infinity, Infinity);
    static full() {
        return this._full;
    }
    _x;
    _y;
    _width;
    _height;
    constructor(x, y, width, height) {
        this._x = x;
        this._y = y;
        this._width = width;
        this._height = height;
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get top() {
        // Infinity - Infinity is NaN, but here we want it to be -Infinity
        if (this._y === Infinity && this._height === -Infinity) {
            return -Infinity;
        }
        return this._height > 0 ? this._y : this._y + this._height;
    }
    get right() {
        // -Infinity + Infinity is NaN, but here we want it to be Infinity
        if (this._x === -Infinity && this._width === Infinity) {
            return Infinity;
        }
        return this._width > 0 ? this._x + this._width : this._x;
    }
    get bottom() {
        // -Infinity + Infinity is NaN, but here we want it to be Infinity
        if (this._y === -Infinity && this._height === Infinity) {
            return Infinity;
        }
        return this._height > 0 ? this._y + this._height : this._y;
    }
    get left() {
        // Infinity - Infinity is NaN, but here we want it to be -Infinity
        if (this._x === Infinity && this._width === -Infinity) {
            return -Infinity;
        }
        return this._width > 0 ? this._x : this._x + this._width;
    }
    get center() {
        // TODO: How to handle infinite rectangles?
        return {
            x: this._x + this._width / 2,
            y: this._y + this._height / 2,
        };
    }
    get area() {
        return this._width * this._height;
    }
    isEmpty() {
        return this.equals(Rectangle.empty());
    }
    isFull() {
        return this.equals(Rectangle.full());
    }
    contains(other) {
        if (other.isEmpty() || this.isFull()) {
            return true;
        }
        return (this.left <= other.left &&
            this.top <= other.top &&
            other.right <= this.right &&
            other.bottom <= this.bottom);
    }
    intersects(other) {
        return (other.left <= this.right &&
            other.top <= this.bottom &&
            other.right >= this.left &&
            other.bottom >= this.top);
    }
    union(other) {
        if (this.contains(other)) {
            return this;
        }
        if (other.contains(this)) {
            return other;
        }
        const minLeft = min(this.left, other.left);
        const minTop = min(this.top, other.top);
        const maxRight = max(this.right, other.right);
        const maxBottom = max(this.bottom, other.bottom);
        return Rectangle.of(minLeft, minTop, maxRight - minLeft, maxBottom - minTop);
    }
    intersection(other) {
        if (!this.intersects(other)) {
            return Rectangle.empty();
        }
        if (this.contains(other)) {
            return other;
        }
        if (other.contains(this)) {
            return this;
        }
        const maxLeft = max(this.left, other.left);
        const maxTop = max(this.top, other.top);
        const minRight = min(this.right, other.right);
        const minBottom = min(this.bottom, other.bottom);
        return Rectangle.of(maxLeft, maxTop, minRight - maxLeft, minBottom - maxTop);
    }
    /**
     * Checks if the rectangle intersects a given circle.
     *
     * @remarks
     * @see ../docs/circle-rectangle-intersection.png for a visual explanation of the case
     * where the circle center lies in one of the corners of the padded rectangle.
     *
     * @privateRemarks
      * To check intersection, we pad the rectangle by the radius of the circle and divide the problem into three cases:
      *
      * 1. The circle center is outside the padded rectangle.
      * 2. The circle center is inside the padded rectangle, but not in one of the corners.
      * 3. The circle center lies in one of the corners of the padded rectangle in which case we need to compute the distance to the corner
      *
      *                 r
      *              +-------+-------------------------+-------+
      *              |       |                         |       |
      *     1        |       |                         |       |
      *              +-------+-------------------------+-------+
      *              |       |                         |       |
      *              |       |                         |       |
      *              |       |                         |       |
      *              |       |                         |       |
      *              |       |                         |       |
      *              +-------+-------------------------+-------+
      *              |       |            2            |       |
      *              | 3     |                         |       |
      *              +-------+-------------------------+-------+
     */
    intersectsCircle(cx, cy, r) {
        const center = this.center;
        const halfWidth = this.width / 2;
        const halfHeight = this.height / 2;
        const dx = Math.abs(cx - center.x);
        const dy = Math.abs(cy - center.y);
        if (dx > halfWidth + r || dy > halfHeight + r) {
            // 1. The circle center is outside the padded rectangle
            return false;
        }
        // The circle center is inside the padded rectangle
        if (dx <= halfWidth || dy <= halfHeight) {
            // 2. The circle lies at most a radius away from the rectangle in the x or y directions
            return true;
        }
        // 3. The circle center lies in one of the corners of the padded rectangle.
        // If the distance from the circle center to the closest corner of the rectangle
        // is less than the radius of the circle, the circle intersects the rectangle.
        return (dx - halfWidth) ** 2 + (dy - halfHeight) ** 2 <= r ** 2;
    }
    /**
     * Computes the squared distance between the centers of two rectangles.
     *
     * @remarks
     * The squared distance is used to avoid the expensive square root operation.
     * If the actual distance is needed, the square root of the squared distance can be taken.
     */
    distanceSquared(other) {
        const c1 = this.center;
        const c2 = other.center;
        return (c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2;
    }
    equals(value) {
        return (value === this ||
            (value instanceof Rectangle &&
                value.top === this.top &&
                value.left === this.left &&
                value.bottom === this.bottom &&
                value.right === this.right));
    }
    hash(hash) {
        hash
            .writeNumber(this._x)
            .writeNumber(this._y)
            .writeNumber(this._width)
            .writeNumber(this._height);
    }
    toJSON() {
        return {
            type: "rectangle",
            x: this._x,
            y: this._y,
            width: this._width,
            height: this._height,
        };
    }
}
/**
 * @public
 */
(function (Rectangle) {
    function from(json) {
        return Rectangle.of(json.x, json.y, json.width, json.height);
    }
    Rectangle.from = from;
    function isRectangle(value) {
        return value instanceof Rectangle;
    }
    Rectangle.isRectangle = isRectangle;
    function union(...rectangles) {
        return rectangles.reduce((previous, current) => previous.union(current), Rectangle.empty());
    }
    Rectangle.union = union;
    function intersection(...rectangles) {
        return rectangles.reduce((previous, current) => previous.intersection(current), Rectangle.full());
    }
    Rectangle.intersection = intersection;
})(Rectangle || (Rectangle = {}));
//# sourceMappingURL=rectangle.js.map