import { Array } from "@siteimprove/alfa-array";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { Map } from "@siteimprove/alfa-map";
import { Predicate } from "@siteimprove/alfa-predicate";
const { not } = Predicate;
/**
 * @public
 */
export class Set {
    static of(...values) {
        return values.reduce((set, value) => set.add(value), Set.empty());
    }
    static _empty = new Set(Map.empty());
    static empty() {
        return this._empty;
    }
    _values;
    constructor(values) {
        this._values = values;
    }
    get size() {
        return this._values.size;
    }
    isEmpty() {
        return this._values.isEmpty();
    }
    forEach(callback) {
        Iterable.forEach(this, callback);
    }
    map(mapper) {
        return this._values.reduce((set, _, value) => set.add(mapper(value)), Set.empty());
    }
    apply(mapper) {
        return mapper.flatMap((mapper) => this.map(mapper));
    }
    flatMap(mapper) {
        return this.reduce((set, value) => set.concat(mapper(value)), Set.empty());
    }
    flatten() {
        return this.flatMap((set) => set);
    }
    reduce(reducer, accumulator) {
        return Iterable.reduce(this, reducer, accumulator);
    }
    filter(predicate) {
        return this.reduce((set, value) => (predicate(value) ? set.add(value) : set), Set.empty());
    }
    reject(predicate) {
        return this.filter(not(predicate));
    }
    find(predicate) {
        return Iterable.find(this, predicate);
    }
    includes(value) {
        return Iterable.includes(this, value);
    }
    collect(mapper) {
        return Set.from(Iterable.collect(this, mapper));
    }
    collectFirst(mapper) {
        return Iterable.collectFirst(this, mapper);
    }
    some(predicate) {
        return Iterable.some(this, predicate);
    }
    none(predicate) {
        return Iterable.none(this, predicate);
    }
    every(predicate) {
        return Iterable.every(this, predicate);
    }
    count(predicate) {
        return Iterable.count(this, predicate);
    }
    /**
     * @remarks
     * As sets don't contain duplicate values, they will only ever contain
     * distinct values.
     */
    distinct() {
        return this;
    }
    get(value) {
        return this._values.get(value);
    }
    has(value) {
        return this._values.has(value);
    }
    add(value) {
        const values = this._values.set(value, value);
        if (values === this._values) {
            return this;
        }
        return new Set(values);
    }
    delete(value) {
        const values = this._values.delete(value);
        if (values === this._values) {
            return this;
        }
        return new Set(values);
    }
    concat(iterable) {
        return Iterable.reduce(iterable, (set, value) => set.add(value), this);
    }
    subtract(iterable) {
        return Iterable.reduce(iterable, (set, value) => set.delete(value), this);
    }
    intersect(iterable) {
        return Set.fromIterable(Iterable.filter(iterable, (value) => this.has(value)));
    }
    tee(callback, ...args) {
        callback(this, ...args);
        return this;
    }
    equals(value) {
        return value instanceof Set && value._values.equals(this._values);
    }
    hash(hash) {
        for (const value of this) {
            hash.writeUnknown(value);
        }
        hash.writeUint32(this._values.size);
    }
    *iterator() {
        for (const [value] of this._values) {
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    toArray() {
        return [...this];
    }
    toJSON(options) {
        return this.toArray().map((value) => Serializable.toJSON(value, options));
    }
    toString() {
        const entries = this.toArray().join(", ");
        return `Set {${entries === "" ? "" : ` ${entries} `}}`;
    }
}
/**
 * @public
 */
(function (Set) {
    function isSet(value) {
        return value instanceof Set;
    }
    Set.isSet = isSet;
    function from(iterable) {
        if (isSet(iterable)) {
            return iterable;
        }
        if (Array.isArray(iterable)) {
            return fromArray(iterable);
        }
        return fromIterable(iterable);
    }
    Set.from = from;
    function fromArray(array) {
        return Array.reduce(array, (set, value) => set.add(value), Set.empty());
    }
    Set.fromArray = fromArray;
    function fromIterable(iterable) {
        return Iterable.reduce(iterable, (set, value) => set.add(value), Set.empty());
    }
    Set.fromIterable = fromIterable;
})(Set || (Set = {}));
//# sourceMappingURL=set.js.map