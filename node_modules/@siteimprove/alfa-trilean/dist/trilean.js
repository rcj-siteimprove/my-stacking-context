import { Iterable } from "@siteimprove/alfa-iterable";
/**
 * @public
 */
export var Trilean;
(function (Trilean) {
    function test(predicate, value, ...args) {
        return predicate(value, ...args);
    }
    Trilean.test = test;
    function fold(predicate, ifTrue, ifFalse, ifUndefined, value, ...args) {
        switch (predicate(value, ...args)) {
            case true:
                return ifTrue(value);
            case false:
                return ifFalse(value);
            case undefined:
                return ifUndefined(value);
        }
    }
    Trilean.fold = fold;
    function not(predicate) {
        return (value, ...args) => {
            switch (predicate(value, ...args)) {
                case true:
                    return false;
                case false:
                    return true;
                case undefined:
                    return undefined;
            }
        };
    }
    Trilean.not = not;
    function and(...predicates) {
        return (value, ...args) => predicates.reduce((holds, predicate) => {
            if (holds === false) {
                return false;
            }
            if (holds === true) {
                return predicate(value, ...args);
            }
            if (predicate(value, ...args) === false) {
                return false;
            }
            else {
                return undefined;
            }
        }, true);
    }
    Trilean.and = and;
    function or(...predicates) {
        return (value, ...args) => predicates.reduce((holds, predicate) => {
            if (holds === true) {
                return true;
            }
            if (holds === false) {
                return predicate(value, ...args);
            }
            if (predicate(value, ...args) === true) {
                return true;
            }
            else {
                return undefined;
            }
        }, false);
    }
    Trilean.or = or;
    function xor(left, right) {
        return and(or(left, right), not(and(left, right)));
    }
    Trilean.xor = xor;
    function nor(left, right) {
        return not(or(left, right));
    }
    Trilean.nor = nor;
    function nand(left, right) {
        return not(and(left, right));
    }
    Trilean.nand = nand;
    function some(iterable, predicate) {
        return Iterable.reduce(iterable, (result, value, i) => test(or(() => result, predicate), value, i), false);
    }
    Trilean.some = some;
    function none(iterable, predicate) {
        return every(iterable, not(predicate));
    }
    Trilean.none = none;
    function every(iterable, predicate) {
        return Iterable.reduce(iterable, (result, value, i) => test(and(() => result, predicate), value, i), true);
    }
    Trilean.every = every;
})(Trilean || (Trilean = {}));
//# sourceMappingURL=trilean.js.map