import { Equatable } from "@siteimprove/alfa-equatable";
import { Serializable } from "@siteimprove/alfa-json";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
const { not, test } = Predicate;
/**
 * @public
 */
export class Err {
    static of(error) {
        return new Err(error);
    }
    _error;
    constructor(error) {
        this._error = error;
    }
    isOk() {
        return false;
    }
    isErr() {
        return true;
    }
    map() {
        return this;
    }
    mapErr(mapper) {
        return new Err(mapper(this._error));
    }
    mapOrElse(ok, err) {
        return err(this._error);
    }
    apply() {
        return this;
    }
    flatMap() {
        return this;
    }
    flatten() {
        return this;
    }
    reduce(reducer, accumulator) {
        return accumulator;
    }
    includes() {
        return false;
    }
    includesErr(error) {
        return Equatable.equals(this._error, error);
    }
    some() {
        return false;
    }
    someErr(predicate) {
        return test(predicate, this._error);
    }
    none() {
        return true;
    }
    noneErr(predicate) {
        return test(not(predicate), this._error);
    }
    every() {
        return true;
    }
    everyErr(predicate) {
        return test(predicate, this._error);
    }
    and() {
        return this;
    }
    andThen() {
        return this;
    }
    or(result) {
        return result;
    }
    orElse(result) {
        return result();
    }
    /**
     * @internal
     */
    getUnsafe(message = "Attempted to .getUnsafe() from Err") {
        throw new Error(message);
    }
    /**
     * @internal
     */
    getErrUnsafe() {
        return this._error;
    }
    getErr() {
        return this._error;
    }
    getOr(value) {
        return value;
    }
    getOrElse(value) {
        return value();
    }
    getErrOr() {
        return this._error;
    }
    getErrOrElse() {
        return this._error;
    }
    ok() {
        return None;
    }
    err() {
        return Option.of(this._error);
    }
    tee() {
        return this;
    }
    teeErr(callback) {
        callback(this._error);
        return this;
    }
    equals(value) {
        return value instanceof Err && Equatable.equals(value._error, this._error);
    }
    hash(hash) {
        hash.writeBoolean(false).writeUnknown(this._error);
    }
    *[Symbol.iterator]() { }
    toJSON(options) {
        return {
            type: "err",
            error: Serializable.toJSON(this._error, options),
        };
    }
    toString() {
        return `Err { ${this._error} }`;
    }
}
/**
 * @public
 */
(function (Err) {
    function isErr(value) {
        return value instanceof Err;
    }
    Err.isErr = isErr;
})(Err || (Err = {}));
//# sourceMappingURL=err.js.map