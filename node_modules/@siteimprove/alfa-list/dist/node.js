import { Bits } from "@siteimprove/alfa-bits";
import { Equatable } from "@siteimprove/alfa-equatable";
import { None, Option } from "@siteimprove/alfa-option";
const { bit, take, skip } = Bits;
/**
 * @internal
 */
export var Node;
(function (Node) {
    Node.Bits = 5;
    Node.Capacity = bit(Node.Bits);
    function fragment(index, shift) {
        return take(skip(index, shift), Node.Bits);
    }
    Node.fragment = fragment;
    function overflow(shift) {
        return Node.Capacity << (shift - Node.Bits);
    }
    Node.overflow = overflow;
    function underflow(shift) {
        return Node.Capacity << (shift - Node.Bits * 2);
    }
    Node.underflow = underflow;
})(Node || (Node = {}));
/**
 * @internal
 */
export const Empty = new (class Empty {
    isEmpty() {
        return true;
    }
    isLeaf() {
        return false;
    }
    get() {
        return None;
    }
    set() {
        return this;
    }
    map() {
        return this;
    }
    equals(value) {
        return value instanceof Empty;
    }
    *[Symbol.iterator]() { }
})();
/**
 * @internal
 */
export class Leaf {
    static of(values) {
        return new Leaf(values);
    }
    _values;
    constructor(values) {
        this._values = values;
    }
    get values() {
        return this._values;
    }
    isEmpty() {
        return false;
    }
    isLeaf() {
        return true;
    }
    hasCapacity() {
        return this._values.length < Node.Capacity;
    }
    get(index) {
        const fragment = take(index, Node.Bits);
        return Option.of(this._values[fragment]);
    }
    set(index, value) {
        const fragment = take(index, Node.Bits);
        if (Equatable.equals(value, this._values[fragment])) {
            return this;
        }
        const values = this._values.slice(0);
        values[fragment] = value;
        return Leaf.of(values);
    }
    map(mapper) {
        return Leaf.of(this._values.map(mapper));
    }
    equals(value) {
        return (value instanceof Leaf &&
            value._values.length === this._values.length &&
            value._values.every((value, i) => Equatable.equals(value, this._values[i])));
    }
    *[Symbol.iterator]() {
        yield* this._values;
    }
}
/**
 * @internal
 */
export class Branch {
    static of(nodes) {
        return new Branch(nodes);
    }
    static empty() {
        return new Branch([]);
    }
    _nodes;
    constructor(nodes) {
        this._nodes = nodes;
    }
    get nodes() {
        return this._nodes;
    }
    isEmpty() {
        return false;
    }
    isLeaf() {
        return false;
    }
    clone() {
        return Branch.of(this._nodes.slice(0));
    }
    get(index, shift) {
        const fragment = Node.fragment(index, shift);
        return this._nodes[fragment].get(index, shift - Node.Bits);
    }
    set(index, value, shift) {
        const fragment = Node.fragment(index, shift);
        const node = this._nodes[fragment].set(index, value, shift - Node.Bits);
        if (node === this._nodes[fragment]) {
            return this;
        }
        const nodes = this._nodes.slice(0);
        nodes[fragment] = node;
        return Branch.of(nodes);
    }
    map(mapper) {
        return Branch.of(this._nodes.map((node) => node.map(mapper)));
    }
    equals(value) {
        return (value instanceof Branch &&
            value._nodes.length === this._nodes.length &&
            value._nodes.every((node, i) => node.equals(this._nodes[i])));
    }
    *[Symbol.iterator]() {
        for (const node of this._nodes) {
            yield* node;
        }
    }
}
//# sourceMappingURL=node.js.map