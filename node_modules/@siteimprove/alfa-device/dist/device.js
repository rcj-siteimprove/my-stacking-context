import { Iterable } from "@siteimprove/alfa-iterable";
import { Map } from "@siteimprove/alfa-map";
import { Display } from "./display.js";
import { Preference } from "./preference.js";
import { Scripting } from "./scripting.js";
import { Viewport } from "./viewport.js";
/**
 * @public
 */
export class Device {
    /**
     * @remarks
     * If the iterable of preferences contains preferences with duplicate names,
     * the last preference with a given name will take precedence.
     */
    static of(type, viewport, display, scripting = Scripting.of(true), preferences = []) {
        return new Device(type, viewport, display, scripting, Map.from(Iterable.map(preferences, (preference) => [
            preference.name,
            preference,
        ])));
    }
    _type;
    _viewport;
    _display;
    _scripting;
    _preferences;
    constructor(type, viewport, display, scripting, preferences) {
        this._type = type;
        this._viewport = viewport;
        this._display = display;
        this._scripting = scripting;
        this._preferences = preferences;
    }
    get type() {
        return this._type;
    }
    get viewport() {
        return this._viewport;
    }
    get display() {
        return this._display;
    }
    get scripting() {
        return this._scripting;
    }
    get preferences() {
        return this._preferences.values();
    }
    preference(name) {
        return this._preferences
            .get(name)
            .getOrElse(() => Preference.unset(name));
    }
    equals(value) {
        return (value instanceof Device &&
            value._type === this._type &&
            value._viewport.equals(this._viewport) &&
            value._display.equals(this._display) &&
            value._scripting.equals(this._scripting) &&
            value._preferences.equals(this._preferences));
    }
    hash(hash) {
        switch (this._type) {
            case Device.Type.Print:
                hash.writeUint8(1);
                break;
            case Device.Type.Screen:
                hash.writeUint8(2);
                break;
            case Device.Type.Speech:
                hash.writeUint8(3);
        }
        hash
            .writeHashable(this._viewport)
            .writeHashable(this._display)
            .writeHashable(this._scripting)
            .writeHashable(this._preferences);
    }
    toJSON(options) {
        return {
            type: this._type,
            viewport: this._viewport.toJSON(options),
            display: this._display.toJSON(options),
            scripting: this._scripting.toJSON(options),
            preferences: [...this._preferences.values()].map((preferece) => preferece.toJSON(options)),
        };
    }
}
/**
 * @public
 */
(function (Device) {
    let Type;
    (function (Type) {
        Type["Print"] = "print";
        Type["Screen"] = "screen";
        Type["Speech"] = "speech";
    })(Type = Device.Type || (Device.Type = {}));
    function from(json) {
        return Device.of(json.type, Viewport.from(json.viewport), Display.from(json.display), Scripting.from(json.scripting), json.preferences.map((json) => Preference.from(json)));
    }
    Device.from = from;
    function standard() {
        return Device.of(Type.Screen, Viewport.standard(), Display.standard());
    }
    Device.standard = standard;
})(Device || (Device = {}));
//# sourceMappingURL=device.js.map