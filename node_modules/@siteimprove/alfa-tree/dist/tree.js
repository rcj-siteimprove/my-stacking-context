/// <reference lib="dom" />
import { Lazy } from "@siteimprove/alfa-lazy";
import { None, Option } from "@siteimprove/alfa-option";
import { Refinement } from "@siteimprove/alfa-refinement";
import { Sequence } from "@siteimprove/alfa-sequence";
import * as json from "@siteimprove/alfa-json";
const { equals } = Refinement;
/**
 * Model for n-ary trees with some traversal flags.
 *
 * In order to have a parent pointers, nodes are allowed to attach themselves
 * to a parent node. To prevent mutation of an existing tree, the child is then
 * "frozen".
 *
 * Since it is not possible to add children after node creation, and it is not
 * possible to re-attach an already attached node, this means that the trees are
 * effectively downward frozen. In turn, this allows a bunch of optimisation
 * since any traversal function that does not look upward can be cached.
 *
 * The full tree (all nodes) must accept the same set of traversal flags, but
 * the node type is not constrained.
 *
 * @public
 */
export class Node {
    _children;
    _parent = None;
    _type;
    // Externally provided data.
    _externalId;
    _extraData;
    _serializationId;
    /**
     * Whether the node is frozen.
     *
     * @remarks
     * As nodes are initialized without a parent and possibly attached to a parent
     * after construction, this makes hierarchies of nodes mutable. That is, a
     * node without a parent node may be assigned one by being passed as a child
     * to a parent node. When this happens, a node becomes frozen. Nodes can also
     * become frozen before being assigned a parent by using the `Node#freeze()`
     * method.
     */
    _frozen = false;
    constructor(children, type, externalId, serializationId, extraData) {
        this._children = children.filter((child) => child._attachParent(this));
        this._type = type;
        this._externalId = externalId;
        this._extraData = extraData;
        this._serializationId = serializationId ?? crypto.randomUUID();
    }
    get type() {
        return this._type;
    }
    get externalId() {
        return this._externalId;
    }
    get extraData() {
        return this._extraData;
    }
    get serializationId() {
        return this._serializationId;
    }
    get frozen() {
        return this._frozen;
    }
    /**
     * Freeze the node. This prevents further expansion of the node hierarchy,
     * meaning that the node can no longer be passed as a child to a parent node.
     */
    freeze() {
        this._frozen = this._frozen || true;
        return this;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-parent}
     */
    parent(options) {
        return this._parent;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-parent}
     */
    isParentOf(node, options) {
        return node.parent(options).includes(this);
    }
    _lastKnownRoot = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-root}
     */
    // Since root is looking upward, it may change between calls.
    // So we cache the last known root, try again from here and update the result
    // if necessary. Once the tree is fully frozen, this only cost an extra look
    // through this.parent which is not expensive.
    root(options) {
        const value = options?.value ?? 0;
        let lastKnownRoot = this._lastKnownRoot[value] ?? this;
        for (const parent of lastKnownRoot.parent(options)) {
            lastKnownRoot = parent.root(options);
        }
        this._lastKnownRoot[value] = lastKnownRoot;
        return lastKnownRoot;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-root}
     */
    isRootOf(node, options) {
        return node.root(options) === this;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-child}
     */
    children(options) {
        return Sequence.from(this._children);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-child}
     */
    isChildOf(node, options) {
        return node.children(options).includes(this);
    }
    _descendants = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-descendant}
     */
    // While this is lazily built, actually generating the sequence takes time to
    // walk through the tree and resolve all the continuations.
    // Caching it saves a lot of time by generating the sequence only once.
    descendants(options) {
        const value = options?.value ?? 0;
        if (this._descendants[value] === undefined) {
            this._descendants[value] = this.children(options).flatMap((child) => Sequence.of(child, Lazy.of(() => child.descendants(options))));
        }
        return this._descendants[value];
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-descendant}
     */
    isDescendantOf(node, options) {
        return node.descendants(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-descendant}
     */
    inclusiveDescendants(options) {
        return Sequence.of(this, Lazy.of(() => this.descendants(options)));
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-descendant}
     */
    isInclusiveDescendantsOf(node, options) {
        return node.inclusiveDescendants(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-ancestor}
     */
    ancestors(options) {
        for (const parent of this.parent(options)) {
            return Sequence.of(parent, Lazy.of(() => parent.ancestors(options)));
        }
        return Sequence.empty();
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-ancestor}
     */
    isAncestorOf(node, options) {
        return node.ancestors(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor}
     */
    inclusiveAncestors(options) {
        return Sequence.of(this, Lazy.of(() => this.ancestors(options)));
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor}
     */
    isInclusiveAncestorOf(node, options) {
        return node.inclusiveAncestors(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-sibling}
     */
    siblings(options) {
        return this.inclusiveSiblings(options).reject(equals(this));
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-sibling}
     */
    isSiblingOf(node, options) {
        return node.siblings(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-sibling}
     */
    inclusiveSiblings(options) {
        for (const parent of this.parent(options)) {
            return parent.children(options);
        }
        return Sequence.empty();
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-sibling}
     */
    isInclusiveSiblingOf(node, options) {
        return node.inclusiveSiblings(options).includes(this);
    }
    _preceding = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-preceding}
     */
    // Due to reversing, this is not lazy and is costly at build time.
    // This only looks in frozen parts of the tree.
    preceding(options) {
        const value = options?.value ?? 0;
        if (this._preceding[value] === undefined) {
            this._preceding[value] = this.inclusiveSiblings(options)
                .takeUntil(equals(this))
                .reverse();
        }
        return this._preceding[value];
    }
    _following = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-following}
     */
    // Due to skipUntil, this is not fully lazy and is costly at build time.
    // This only looks in frozen parts of the tree.
    following(options) {
        const value = options?.value ?? 0;
        if (this._following[value] === undefined) {
            this._following[value] = this.inclusiveSiblings(options)
                .skipUntil(equals(this))
                .rest();
        }
        return this._following[value];
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-first-child}
     */
    // Sequence.first() is fast and doesn't need caching
    first(options) {
        return this.children(options).first();
    }
    _last = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-last-child}
     */
    // Due to last, this is not lazy and is costly at build time.
    // This only looks in frozen parts of the tree.
    last(options) {
        const value = options?.value ?? 0;
        if (this._last[value] === undefined) {
            this._last[value] = this.children(options).last();
        }
        return this._last[value];
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-previous-sibling}
     */
    previous(options) {
        return this.preceding(options).first();
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-next-sibling}
     */
    next(options) {
        return this.following(options).first();
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-index}
     */
    index(options) {
        return this.preceding(options).size;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#dom-element-closest}
     */
    closest(predicate, options) {
        return this.inclusiveAncestors(options).find(predicate);
    }
    *[Symbol.iterator]() {
        yield* this.descendants();
    }
    equals(value) {
        return value === this;
    }
    hash(hash) {
        hash.writeObject(this);
    }
    toJSON(options) {
        const verbosity = options?.verbosity ?? json.Serializable.Verbosity.Medium;
        const result = {
            type: this._type,
        };
        if (verbosity < json.Serializable.Verbosity.Medium) {
            // Only type and serializationId
            result.serializationId = this._serializationId;
            return result;
        }
        // If verbosity is Medium or above, include everything (except serializationId)
        result.children = this._children.map((child) => child.toJSON(options));
        if (this._externalId !== undefined) {
            result.externalId = this._externalId;
        }
        if (verbosity >= json.Serializable.Verbosity.High) {
            // If verbosity is High or above, include also serializationId
            result.serializationId = this._serializationId;
        }
        return result;
    }
    /**
     * @internal
     */
    _attachParent(parent) {
        if (this._frozen || this._parent.isSome()) {
            return false;
        }
        this._parent = Option.of(parent);
        this._frozen = true;
        return true;
    }
}
//# sourceMappingURL=tree.js.map