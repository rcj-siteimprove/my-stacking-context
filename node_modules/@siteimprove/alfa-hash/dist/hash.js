import { Encoder } from "@siteimprove/alfa-encoding";
import { Hashable } from "./hashable.js";
const { keys } = Object;
/**
 * A special offset used for the builtin types `true`, `false`, `undefined`, and
 * `null`. The offset is designed to minimize the chance of collisions for data
 * structures that rely on 5-bit partitioning. We use the first 30 bits for 6 of
 * these partitions, leaving us 2 bits to encode the 4 builtin types.
 */
const builtinOffset = 0b10000_10000_10000_10000_10000_10000_00;
/**
 * @public
 */
export class Hash {
    /**
     * A map from objects to their hash values. Objects are weakly referenced as
     * to not prevent them from being garbage collected.
     */
    static _objectHashes = new WeakMap();
    /**
     * A map from symbols to their hash values. As there's not currently a way to
     * weakly reference symbols, we have to instead use strong references.
     *
     * {@link https://github.com/tc39/proposal-symbols-as-weakmap-keys}
     */
    static _symbolHashes = new Map();
    /**
     * The next available hash value. This is used for symbols and objects that
     * don't implement the {@link (Hashable:interface)} interface.
     */
    static _nextHash = 0;
    constructor() { }
    writeString(data) {
        return this.write(Encoder.encode(data));
    }
    /**
     * @remarks
     * As JavaScript represents numbers in double-precision floating-point format,
     * numbers in general will be written as such.
     *
     * {@link https://en.wikipedia.org/wiki/Double-precision_floating-point_format}
     */
    writeNumber(data) {
        return this.writeFloat64(data);
    }
    writeInt(data, size = 32, signed = true) {
        const buffer = new ArrayBuffer(size / 8);
        const view = new DataView(buffer);
        switch (size) {
            case 8:
                signed ? view.setInt8(0, data) : view.setUint8(0, data);
                break;
            case 16:
                signed ? view.setInt16(0, data) : view.setUint16(0, data);
                break;
            case 32:
                signed ? view.setInt32(0, data) : view.setUint32(0, data);
        }
        return this.write(new Uint8Array(buffer));
    }
    writeInt8(data) {
        return this.writeInt(data, 8, true);
    }
    writeUint8(data) {
        return this.writeInt(data, 8, false);
    }
    writeInt16(data) {
        return this.writeInt(data, 16, true);
    }
    writeUint16(data) {
        return this.writeInt(data, 16, false);
    }
    writeInt32(data) {
        return this.writeInt(data, 32, true);
    }
    writeUint32(data) {
        return this.writeInt(data, 32, false);
    }
    writeBigInt(data, size = 64, signed = true) {
        const buffer = new ArrayBuffer(size / 8);
        const view = new DataView(buffer);
        switch (size) {
            case 64:
                signed ? view.setBigInt64(0, data) : view.setBigUint64(0, data);
        }
        return this.write(new Uint8Array(buffer));
    }
    writeBigInt64(data) {
        return this.writeBigInt(data, 64, true);
    }
    writeBigUint64(data) {
        return this.writeBigInt(data, 64, false);
    }
    writeFloat(data, size = 32) {
        const buffer = new ArrayBuffer(size / 8);
        const view = new DataView(buffer);
        switch (size) {
            case 32:
                view.setFloat32(0, data);
                break;
            case 64:
                view.setFloat64(0, data);
        }
        return this.write(new Uint8Array(buffer));
    }
    writeFloat32(data) {
        return this.writeFloat(data, 32);
    }
    writeFloat64(data) {
        return this.writeFloat(data, 64);
    }
    writeBoolean(data) {
        return this.writeUint8(builtinOffset + (data ? 1 : 0));
    }
    writeUndefined() {
        return this.writeUint32(builtinOffset + 2);
    }
    writeNull() {
        return this.writeUint32(builtinOffset + 3);
    }
    writeObject(data) {
        let hash = Hash._objectHashes.get(data);
        if (hash === undefined) {
            hash = Hash._getNextHash();
            Hash._objectHashes.set(data, hash);
        }
        return this.writeUint32(hash);
    }
    writeSymbol(data) {
        let hash = Hash._symbolHashes.get(data);
        if (hash === undefined) {
            hash = Hash._getNextHash();
            Hash._symbolHashes.set(data, hash);
        }
        return this.writeUint32(hash);
    }
    writeHashable(data) {
        data.hash(this);
        return this;
    }
    writeUnknown(data) {
        switch (typeof data) {
            case "string":
                return this.writeString(data);
            case "number":
                return this.writeNumber(data);
            case "bigint":
                return this.writeBigInt(data);
            case "boolean":
                return this.writeBoolean(data);
            case "symbol":
                return this.writeSymbol(data);
            case "undefined":
                return this.writeUndefined();
            case "object":
                if (data === null) {
                    return this.writeNull();
                }
                if (Hashable.isHashable(data)) {
                    return this.writeHashable(data);
                }
                return this.writeObject(data);
            case "function":
                return this.writeObject(data);
        }
    }
    writeJSON(data) {
        switch (typeof data) {
            case "string":
                return this.writeString(data);
            case "number":
                return this.writeNumber(data);
            case "boolean":
                return this.writeBoolean(data);
            case "object":
                if (Array.isArray(data)) {
                    for (let i = 0, n = data.length; i < n; i++) {
                        this.writeJSON(data[i]);
                    }
                    this.writeUint32(data.length);
                }
                else if (data !== null) {
                    for (const key of keys(data).sort()) {
                        const value = data[key];
                        this.writeString(key);
                        if (value !== undefined) {
                            this.writeJSON(value);
                        }
                        // Write a null byte as a separator between key/value pairs.
                        this.writeUint8(0);
                    }
                }
                return this;
        }
    }
    equals(value) {
        return value instanceof Hash && value.finish() === this.finish();
    }
    hash(hash) {
        hash.writeUint32(this.finish());
    }
    static _getNextHash() {
        const nextHash = Hash._nextHash;
        // Increase the hash, wrapping around when it reaches the limit of 32 bits.
        Hash._nextHash = (Hash._nextHash + 1) >>> 0;
        return nextHash;
    }
}
//# sourceMappingURL=hash.js.map