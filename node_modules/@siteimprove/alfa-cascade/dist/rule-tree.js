import { Iterable } from "@siteimprove/alfa-iterable";
import { None, Option } from "@siteimprove/alfa-option";
import { Block } from "./block.js";
import { Precedence } from "./precedence/index.js";
/**
 * The rule tree is a data structure used for storing the rules that match each
 * element when computing cascade for a document.
 *
 * @remarks
 * Rules are stored in order from most to least precedence (according to cascade
 * sorting order); rules lower in the tree have therefore higher precedence than
 * rules higher in the tree. Each element gets a pointer to the highest
 * precedence rule it matched and can then follow pointers up the rule tree to
 * locate rules of decreasing precedence that the element also matches. This
 * allows elements that share matched rules to also share a path in the rule tree.
 *
 * As an example, consider elements `A = <div class="foo" href="A">`  and
 * `B = <div class="foo bar">`. Element A matches rules `div`, `.foo` and
 * `.foo[href]` whereas element B matches rules `div`, `.foo` and `.bar`. The
 * naÃ¯ve approach to associating these matched rules with elements
 * would be to associate an array of `[".foo[href]", ".foo", "div"]` with
 * element A and an array of `[".bar", ".foo", "div"]` with element B. With the
 * rule tree, we instead start by inserting the matched rules for element A into
 * the tree:
 *
 *  "div"
 *  +-- ".foo"
 *      +-- ".foo[href]"     (A)
 *
 * We then associate rule `".foo[href]"` with element A and insert the matched
 * rules for element B into the tree:
 *
 *  "div"
 *  +-- ".foo"
 *      +-- ".foo[href]"    (A)
 *      +-- ".bar"          (B)
 *
 * We then associate the rule `".bar"` with element B, and we're done. Notice how
 * the tree branches at rule `".foo"`, allowing the two elements to share the
 * path in the rule tree that they have in common. This approach is conceptually
 * similar to associating arrays of matched rules with elements with the
 * difference being that we use linked lists instead of arrays, allowing us to
 * share parts of the list between elements. This allows for a much more memory
 * efficient way of associating matched rules with elements, in particular for
 * rules that match most elements, such as the universal selector or `html` and
 * `body`.
 *
 * Note that the resulting rule tree depends greatly on the order in which
 * rules are inserted, which must then be by increasing precedence. The `.foo`
 * and `.bar` selectors are not directly comparable; the example above assumes
 * that the `.bar` rule came later in the style sheet order and therefore wins
 * the cascade sort by "Order of Appearance". This information is not available
 * for the rule tree which relies on rules being fed to it in increasing
 * precedence for each element. If `.bar` came before `.foo`, the resulting tree
 * would be (notice that `.foo` is not sharable anymore):
 *
 * "div"
 * +-- ".foo"
 *     +-- ".foo[href]"   (A)
 * +-- ".bar"
 *     +-- ".foo"         (B)
 *
 * {@link http://doc.servo.org/style/rule_tree/struct.RuleTree.html}
 *
 * @privateRemarks
 * The rules tree is actually a forest of nodes since many elements do not share
 * any matched selector. We artificially root it at a fake node with no
 * declarations, hence no impact on style. The fake root is not serialized.
 *
 * @public
 */
export class RuleTree {
    static empty() {
        return new RuleTree();
    }
    // Rooting the forest at a fake node with no declaration.
    _root = RuleTree.Node.of(Block.empty(), [], None);
    constructor() { }
    /**
     * Add a bunch of items to the tree. Returns the last node created, which is
     * the highest precedence node for that list of items.
     *
     * @remarks
     * The rules are assumed to be:
     * 1. all matching the same element; and
     * 2. be all the rules matching that element.
     *
     * It is up to the caller to ensure this is true, as the tree itself cannot
     * check that (notably, it has no access to the DOM tree to ensure the rules
     * match the same element; nor to the origin or order of the rules to check
     * cascade order).
     *
     * @privateRemarks
     * This is stateful. Adding rules to a rule tree does mutate it!
     *
     * @internal
     */
    add(rules) {
        let parent = this._root;
        for (const block of Iterable.sortWith(rules, Block.compare)) {
            // Insert the next rule into the current parent, using the returned rule
            // entry as the parent of the next rule to insert. This way, we gradually
            // build up a path of rule entries and then return the final entry to the
            // caller.
            parent = parent.add(block);
        }
        return parent;
    }
    toJSON() {
        return this._root.children.map((node) => node.toJSON());
    }
}
/**
 * @public
 */
(function (RuleTree) {
    class Node {
        static of(block, children, parent) {
            return new Node(block, children, parent);
        }
        _block;
        _children;
        _parent;
        constructor(block, children, parent) {
            this._block = block;
            this._children = children;
            this._parent = parent;
        }
        get block() {
            return this._block;
        }
        get children() {
            return this._children;
        }
        get parent() {
            return this._parent;
        }
        *ancestors() {
            for (const parent of this._parent) {
                yield parent;
                yield* parent.ancestors();
            }
        }
        *inclusiveAncestors() {
            yield this;
            yield* this.ancestors();
        }
        /**
         * Adds style rule to a node in the tree. Returns the node where the rule
         * was added.
         *
         * @remarks
         * Blocks with no selector, aka coming from a style attribute, will always be
         * added as new nodes.
         *
         * @privateRemarks
         * This is stateful. Adding a rule to a node mutates the node!
         *
         * @internal
         */
        add(block) {
            // If we have already encountered the exact same selector (physical identity),
            // with declarations of the same importance, we're done.
            // Because blocks are split by importance, the same selector can appear
            // once per importance when the rules are grouped.
            // This occurs when the exact same style rule matches several elements.
            // The first element added to the rule tree will add that rule, subsequent
            // ones will just reuse it (if the path so far in the rule tree has
            // completely been shared).
            // Notably, because it is the exact same selector, it controls the exact
            // same rules, so all the information is already in the tree.
            if (
            // We cannot simply test === between the .selector because we do not
            // want to identify two null.
            (this._block.selector ?? 0) === (block.selector ?? 1) &&
                Precedence.isImportant(this._block.precedence) ===
                    Precedence.isImportant(block.precedence)) {
                return this;
            }
            // Otherwise, if there is a child with an identical but separate selector,
            // recursively add to it.
            // This happens, e.g., when encountering two ".foo" selectors. They are
            // then sorted by order of appearance (by assumption) and the later must
            // be a descendant of the former as it has higher precedence.
            for (const child of this._children) {
                if (
                // We cannot simply test .equals between the .selector because we do not
                // want to identify two None.
                child._block.selector !== null &&
                    child._block.selector.equals(block.selector)) {
                    return child.add(block);
                }
            }
            // Otherwise, the selector is brand new (for this branch of the tree).
            // Add it as a new child and return it (further rules in the same batch,
            // matching the same element, should be added as its child.
            const node = Node.of(block, [], Option.of(this));
            this._children.push(node);
            return node;
        }
        toJSON() {
            return {
                block: this._block.toJSON(),
                children: this._children.map((node) => node.toJSON()),
            };
        }
    }
    RuleTree.Node = Node;
})(RuleTree || (RuleTree = {}));
//# sourceMappingURL=rule-tree.js.map