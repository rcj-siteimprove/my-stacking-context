import { Array } from "@siteimprove/alfa-array";
import {} from "@siteimprove/alfa-comparable";
import { Lexer } from "@siteimprove/alfa-css";
import { Element, h } from "@siteimprove/alfa-dom";
import { Equatable } from "@siteimprove/alfa-equatable";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { None } from "@siteimprove/alfa-option";
import { Selector, Specificity, Universal, } from "@siteimprove/alfa-selector";
import { Layer, Origin, Precedence } from "./precedence/index.js";
import { UserAgent } from "./user-agent.js";
/**
 * While resolving cascade, a Block is a style rule that has been expanded with
 * its selector pre-parsed, its declarations extracted, and extra information
 * about Cascade Sorting Precedence.
 *
 * @remarks
 * Blocks imply coupling between the different parts and are thus grouped into
 * a single structure.
 *
 * Blocks form the data stored in the rule tree and selector map. Upon building the
 * cascade, style rules are turned into Blocks which are inserted into the selector
 * map; and then relevant Blocks are inserted into the rule tree upon matching elements.
 *
 * @internal
 */
export class Block {
    /**
     * Create a block.
     *
     * @remarks
     * This does not validate coupling of the data. Prefer using Block.from()
     *
     * @privateRemarks
     * We need to accept unlayered blocks since this is how they are built.
     */
    static of(source, declarations, precedence) {
        return new Block(source, Array.from(declarations), precedence);
    }
    static _empty = new Block({
        rule: h.rule.style("*", []),
        selector: Universal.of(None),
    }, [], Precedence.empty);
    /**
     * @internal
     */
    static empty() {
        return this._empty;
    }
    // These could be Options instead.
    // However, these (especially the selector) are used on hot path when
    // resolving cascade. Having them nullable, and encoding the nullability
    // in the type, allow for direct access without the small overhead of Options.
    _rule;
    _selector;
    _owner;
    _declarations;
    _precedence;
    constructor(source, declarations, precedence) {
        if (Element.isElement(source)) {
            this._rule = null;
            this._selector = null;
            this._owner = source;
        }
        else {
            this._rule = source.rule;
            this._selector = source.selector;
            this._owner = null;
        }
        this._declarations = declarations;
        this._precedence = precedence;
    }
    get source() {
        return this._owner !== null
            ? this._owner
            : // By construction if owner is unset, then rule and selector are set.
                { rule: this._rule, selector: this._selector };
    }
    get rule() {
        return this._rule;
    }
    get selector() {
        return this._selector;
    }
    get owner() {
        return this._owner;
    }
    get declarations() {
        return this._declarations;
    }
    get precedence() {
        return this._precedence;
    }
    equals(value) {
        return (value instanceof Block &&
            Equatable.equals(value._rule, this._rule) &&
            Equatable.equals(value._selector, this._selector) &&
            Equatable.equals(value._owner, this._owner) &&
            Array.equals(value._declarations, this._declarations) &&
            Precedence.equals(value._precedence, this._precedence));
    }
    toJSON() {
        return {
            source: (Element.isElement(this._owner)
                ? this._owner.toJSON()
                : {
                    rule: this._rule.toJSON(),
                    selector: Serializable.toJSON(this._selector),
                }),
            declarations: Array.toJSON(this._declarations),
            precedence: Precedence.toJSON(this._precedence),
        };
    }
}
/**
 * @internal
 */
(function (Block) {
    /**
     * Build Blocks from a style rule. Returns the last order used, that is unchanged
     * if selector couldn't be parsed, increased by 1 otherwise.
     *
     * @remarks
     * Order is relative to the list of all style rules and thus cannot be inferred
     * from the rule itself.
     *
     * A single rule creates more than one block.
     * * Declarations inside the rule are split by importance.
     * * Rules with a list selector are split into their components.
     *   E.g., a `div, span { color: red }` rule will create one block
     *   for `div { color: red }`, and a similar one for `span`.
     * Since all these blocks are declared at the same time, and are either declaring
     * the exact same declarations, or non-conflicting ones (due to importance), they can
     * share the exact same order.
     */
    function from(rule, order, encapsulationDepth, 
    // It is actually the same layer, but the rules are split into block by importance,
    // and we need to reflect that in the layers.
    layer) {
        const blocks = [];
        for (const [_, selectors] of Selector.parse(Lexer.lex(rule.selector))) {
            // The selector was parsed successfully, so blocks will be created, and we need to update order.
            order++;
            for (const [importance, declarations] of Iterable.groupBy(rule.style.declarations, (declaration) => declaration.important)) {
                const origin = rule.owner.includes(UserAgent)
                    ? importance
                        ? Origin.ImportantUserAgent
                        : Origin.NormalUserAgent
                    : importance
                        ? Origin.ImportantAuthor
                        : Origin.NormalAuthor;
                for (const selector of selectors) {
                    // While we don't really know where the rules will be used, and they all look
                    // "outer" from this point of view, we also know that the shadow rules cannot
                    // match within the current tree, and can only match an encapsulating light tree.
                    // Therefore, for anything that will actually match a shadow selector, the selector
                    // appears as encapsulated.
                    const encapsulation = importance
                        ? // Important declarations have positive encapsulation depth, deeper wins.
                            encapsulationDepth
                        : // Normal declarations have negative encapsulation depth, deeper loses.
                            -encapsulationDepth;
                    blocks.push(Block.of({ rule, selector }, declarations, {
                        origin,
                        encapsulation,
                        isElementAttached: false,
                        layer: importance ? layer.important : layer.normal,
                        order,
                        specificity: selector.specificity,
                    }));
                }
            }
        }
        return [blocks, order];
    }
    Block.from = from;
    /**
     * Turns the style attribute of an element into blocks (one for important
     * declarations, one for normal declarations).
     */
    function fromStyle(element, encapsulationDepth) {
        return element.style
            .map((style) => Iterable.map(Iterable.groupBy(style.declarations, (declaration) => declaration.important), ([importance, declarations]) => Block.of(element, declarations, {
            origin: importance ? Origin.ImportantAuthor : Origin.NormalAuthor,
            encapsulation: importance
                ? // Important declarations have positive encapsulation depth, deeper wins.
                    encapsulationDepth
                : // Normal declarations have negative encapsulation depth, deeper loses.
                    -encapsulationDepth,
            isElementAttached: true,
            // Since style attribute trumps layer, specificity and order in the cascade sort,
            // and there is at most one style attribute per element,
            // these never matters and we can use any placeholder.
            layer: Layer.empty(),
            specificity: Specificity.empty(),
            order: -1,
        })))
            .getOr([]);
    }
    Block.fromStyle = fromStyle;
    Block.compare = (a, b) => Precedence.compare(a.precedence, b.precedence);
})(Block || (Block = {}));
//# sourceMappingURL=block.js.map