import { Comparable, Comparison, } from "@siteimprove/alfa-comparable";
import { Flags } from "@siteimprove/alfa-flags";
import { Lazy } from "@siteimprove/alfa-lazy";
import { Option } from "@siteimprove/alfa-option";
import { Selective } from "@siteimprove/alfa-selective";
import { Sequence } from "@siteimprove/alfa-sequence";
import { String } from "@siteimprove/alfa-string";
import * as tree from "@siteimprove/alfa-tree";
import { Attribute, Comment, Document, Element, Fragment, Shadow, Slot, Slotable, Text, Type, } from "./index.js";
import * as predicate from "./node/predicate.js";
import * as traversal from "./node/traversal.js";
/**
 * @public
 */
export class Node extends tree.Node {
    constructor(children, type, externalId, serializationId, extraData) {
        super(children, type, externalId, serializationId, extraData);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-descendant-text-content}
     */
    textContent(options = Node.Traversal.empty) {
        return String.flatten(this.descendants(options).filter(Text.isText).join(""));
    }
    /**
     * Construct a sequence of descendants of this node sorted by tab index. Only
     * nodes with a non-negative tab index are included in the sequence.
     *
     * {@link https://html.spec.whatwg.org/multipage/#tabindex-value}
     */
    tabOrder() {
        /**
         * Gather candidates for sequential focus navigation.
         *
         * @remarks
         * These are all elements that are keyboard focusable (non-negative
         * tabIndex), plus the shadow hosts and content elements that may contain
         * focusable descendants.
         *
         * It is important that the traversal is done here on the DOM tree only.
         * The shadow trees and content documents will be expanded later. Doing it
         * too early potentially would mix their elements during sorting of the
         * tabIndexes.
         */
        function candidates(node) {
            if (Element.isElement(node)) {
                const element = node;
                const tabIndex = element.tabIndex();
                // If the element is a shadow host that doesn't block keyboard navigation
                // we record it to later expand its shadow tree.
                if (element.shadow.isSome()) {
                    // If the element has a negative tab index and is a shadow host then
                    // none of its descendants will be part of the tab order.
                    if (tabIndex.some((i) => i < 0)) {
                        return Sequence.empty();
                    }
                    else {
                        return Sequence.of([element, tabIndex]);
                    }
                }
                // If the element contains a content document, we record it to later
                // expand its content.
                if (element.content.isSome()) {
                    return Sequence.of([element, tabIndex]);
                }
                // If the element is a slot, we replace it by its assigned nodes.
                if (Slot.isSlot(element)) {
                    return Sequence.from(element.assignedNodes())
                        .filter(Element.isElement)
                        .map((element) => [element, tabIndex]);
                }
                // If the element is keyboard focusable, record it and recurse.
                if (tabIndex.some((i) => i >= 0)) {
                    return Sequence.of([element, tabIndex], Lazy.of(() => element.children().flatMap(candidates)));
                }
            }
            // Otherwise (not an element, or not keyboard focusable), recurse into the children.
            return node.children().flatMap(candidates);
        }
        /**
         * Compare two elements, with non-negative tabindexes, by tabindex.
         *
         * @remarks
         * Due to non-focusable shadow hosts being candidates (for shadow DOM
         * expansion), we may have some indexes being None. These must be treated
         * as 0 (insert in DOM order), rather than smaller than actual indexes
         * (insert at start). Therefore, we cannot use Option.compareWith.
         */
        const comparer = ([, a], [, b]) => {
            const aValue = a.getOr(0);
            const bValue = b.getOr(0);
            return aValue === 0
                ? // "normal order" must come after any "specific order",
                    // i.e., 0 is greater than any positive number.
                    bValue === 0
                        ? Comparison.Equal
                        : Comparison.Greater
                : bValue === 0
                    ? // aValue cannot be 0 anymore.
                        Comparison.Less
                    : // If none are 0, simply compare the values.
                        Comparable.compare(aValue, bValue);
        };
        /**
         * Expand an element into the sequentially focusable elements in its
         * shadow tree or content document.
         *
         * @remarks
         * It is important that this expansion happens **after** sorting by tabindex
         * since shadow DOM and content documents build their own sequential focus
         * order that is inserted as-is in the light tree or parent browsing context.
         * That is, a tabindex of 1 in a shadow tree or content document does
         * **not** come before a tabindex of 2 in the main document.
         */
        function expand([element, tabIndex]) {
            // In case of shadow host, we include it if its sequentially focusable,
            // and always recurse into the shadow tree.
            for (const shadow of element.shadow) {
                if (tabIndex.some((i) => i >= 0)) {
                    return Sequence.of(element, Lazy.of(() => shadow.tabOrder()));
                }
                else {
                    return shadow.tabOrder();
                }
            }
            // In case of content document, we always ignore the host (iframe) which
            // usually redirects focus to the content.
            for (const content of element.content) {
                return content.tabOrder();
            }
            // If no shadow or content document, just keep the element.
            return Sequence.of(element);
        }
        return candidates(this).sortWith(comparer).flatMap(expand);
    }
    parent(options = Node.Traversal.empty) {
        const parent = this._parent;
        // If we traverse the flat tree, we want to jump over shadow roots.
        if (options.isSet(Node.Traversal.flattened)) {
            return parent.flatMap((parent) => {
                if (Shadow.isShadow(parent)) {
                    return parent.host;
                }
                // Additionally, if this is a slottable light child of a shadow host, we want
                // to search for where it is slotted, and return that parent instead.
                if (Element.isElement(parent) &&
                    parent.shadow.isSome() &&
                    Slotable.isSlotable(this)) {
                    return this.assignedSlot().flatMap((slot) => slot.parent(options));
                }
                return Option.of(parent);
            });
        }
        return parent;
    }
    _path = [];
    /**
     * @internal
     */
    _internalPath(options) {
        let path = this.parent(options)
            .map((parent) => parent.path(options))
            .getOr("/");
        path += path === "/" ? "" : "/";
        path += "node()";
        path += `[${this.index(options) + 1}]`;
        return path;
    }
    /**
     * Get an XPath that uniquely identifies the node across descendants of its
     * root.
     */
    // path may change if the subtree is attached to a parent, so we shouldn't
    // cache it.
    // However, path is a fairly "final" serialisation operation that makes
    // little sense in the context of an incomplete tree.
    // For the sake of simplicity, and until we encounter errors due to this,
    // we accept the risk of caching the value assuming that it will only be
    // computed on fully frozen trees.
    path(options = Node.Traversal.empty) {
        if (this._path[options.value] !== undefined) {
            return this._path[options.value];
        }
        else {
            this._path[options.value] = this._internalPath(options);
            return this._internalPath(options);
        }
    }
    equals(value) {
        return value === this;
    }
    toEARL() {
        return {
            "@context": {
                ptr: "http://www.w3.org/2009/pointers#",
            },
            "@type": [
                "ptr:Pointer",
                "ptr:SinglePointer",
                "ptr:ExpressionPointer",
                "ptr:XPathPointer",
            ],
            "ptr:expression": this.path(),
        };
    }
    toSARIF() {
        return {
            logicalLocations: [
                {
                    fullyQualifiedName: this.path(),
                },
            ],
        };
    }
}
/**
 * @public
 */
(function (Node) {
    function isNode(value) {
        return value instanceof Node;
    }
    Node.isNode = isNode;
    class Traversal extends Flags {
        static of(...flags) {
            return new Traversal(Flags._reduce(...flags));
        }
    }
    Node.Traversal = Traversal;
    (function (Traversal) {
        Traversal.none = 0;
        /**
         * When set, traverse the node in shadow-including tree order.
         *
         * {@link https://dom.spec.whatwg.org/#concept-shadow-including-tree-order}
         */
        Traversal.composed = (1 << 0);
        /**
         * When set, traverse the flattened element tree rooted at the node.
         *
         * {@link https://drafts.csswg.org/css-scoping/#flat-tree}
         */
        Traversal.flattened = (1 << 1);
        /**
         * When set, traverse all nested browsing contexts encountered.
         *
         * {@link https://html.spec.whatwg.org/#nested-browsing-context}
         */
        Traversal.nested = (1 << 2);
        Traversal.empty = Traversal.of(Traversal.none);
    })(Traversal = Node.Traversal || (Node.Traversal = {}));
    /**
     * Traversal options to traverse the flat tree.
     *
     * {@link https://drafts.csswg.org/css-scoping-1/#flattening}
     */
    Node.flatTree = Traversal.of(Traversal.flattened);
    /**
     * Traversal options to traverse all relevant nodes (flat tree and inside
     * nested browsing container), a very frequent use case.
     */
    Node.fullTree = Traversal.of(Traversal.flattened, Traversal.nested);
    /**
     * Traversal options to traverse in shadow-including tree order and inside
     * nested browsing context container, a common use case.
     */
    Node.composedNested = Traversal.of(Traversal.composed, Traversal.nested);
    function from(json, device) {
        return fromNode(json, device).run();
    }
    Node.from = from;
    /**
     * @internal
     */
    function fromNode(json, device) {
        switch (json.type) {
            case "element":
                return Element.fromElement(json, device);
            case "attribute":
                return Attribute.fromAttribute(json);
            case "text":
                return Text.fromText(json);
            case "comment":
                return Comment.fromComment(json);
            case "document":
                return Document.fromDocument(json, device);
            case "type":
                return Type.fromType(json);
            case "fragment":
                return Fragment.fromFragment(json, device);
            default:
                throw new Error(`Unexpected node of type: ${json.type}`);
        }
    }
    Node.fromNode = fromNode;
    function clone(node, options, device) {
        return cloneNode(node, options, device).run();
    }
    Node.clone = clone;
    /**
     * @internal
     */
    function cloneNode(node, options = {
        predicate: () => false,
        newElements: [],
    }, device) {
        return Selective.of(node)
            .if(Element.isElement, Element.cloneElement(options, device))
            .if(Attribute.isAttribute, Attribute.cloneAttribute)
            .if(Text.isText, Text.cloneText)
            .if(Comment.isComment, Comment.cloneComment)
            .if(Document.isDocument, Document.cloneDocument(options, device))
            .if(Type.isType, Type.cloneType)
            .if(Fragment.isFragment, Fragment.cloneFragment(options, device))
            .if(Shadow.isShadow, Shadow.cloneShadow(options, device))
            .else(() => {
            throw new Error(`Unexpected node of type: ${node.type}`);
        })
            .get();
    }
    Node.cloneNode = cloneNode;
    Node.getNodesBetween = traversal.getNodesBetween;
    Node.hasChild = predicate.hasChild, Node.hasDescendant = predicate.hasDescendant, Node.hasInclusiveDescendant = predicate.hasInclusiveDescendant, Node.hasTextContent = predicate.hasTextContent, Node.isRoot = predicate.isRoot;
})(Node || (Node = {}));
//# sourceMappingURL=node.js.map