import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Device } from "@siteimprove/alfa-device";
import { Attribute, Block, Declaration, Document, Element, FontFaceRule, Fragment, ImportRule, Layer, KeyframeRule, KeyframesRule, MediaRule, Namespace, NamespaceRule, PageRule, Shadow, Sheet, StyleRule, SupportsRule, Text, Type, } from "./index.js";
const { entries } = Object;
const { nor } = Predicate;
/**
 * @public
 */
export function h(name, attributes, children, style, box, device = Device.standard(), externalId, serializationId, extraData) {
    return h.element(name, attributes, children, style, undefined, box, device, externalId, serializationId, extraData);
}
/**
 * @public
 */
(function (h) {
    function element(name, attributes = [], children = [], style = [], namespace, box, device, externalId, serializationId, extraData) {
        attributes = Array.isArray(attributes)
            ? attributes
            : entries(attributes).reduce((attributes, [name, value]) => {
                if (value === false) {
                    return attributes;
                }
                return [
                    ...attributes,
                    h.attribute(hyphenate(name), value === true ? "" : value),
                ];
            }, []);
        const block = h.block(style);
        if (block.size > 0) {
            attributes = [...attributes, h.attribute("style", block.toString())];
        }
        namespace =
            namespace ??
                Option.from(attributes.find((attribute) => attribute.name === "xmlns"))
                    .map((attribute) => attribute.value)
                    .filter(Namespace.isNamespace)
                    .getOr(defaultNamespace(name));
        const content = children.find(Document.isDocument);
        const shadow = children.find(Shadow.isShadow);
        const element = Element.of(Option.of(namespace), None, name, attributes, children
            .filter(nor(Document.isDocument, Shadow.isShadow))
            .map((child) => (typeof child === "string" ? h.text(child) : child)), (Array.isArray(style) && style.length === 0) ||
            Object.keys(style).length === 0
            ? None
            : Option.of(block), Option.from(box), Option.from(device), externalId, serializationId, extraData);
        if (content !== undefined) {
            element._attachContent(content);
        }
        if (shadow !== undefined) {
            element._attachShadow(shadow);
        }
        return element;
    }
    h.element = element;
    function attribute(name, value, externalId, serializationId, extraData) {
        return Attribute.of(None, None, name, value, externalId, serializationId, extraData);
    }
    h.attribute = attribute;
    function text(data, externalId, serializationId, extraData) {
        return Text.of(data, externalId, serializationId, extraData);
    }
    h.text = text;
    function document(children, style, externalId, serializationId, extraData) {
        return Document.of(children.map((child) => typeof child === "string" ? text(child) : child), style, externalId, serializationId, extraData);
    }
    h.document = document;
    function shadow(children, style, mode, externalId, serializationId, extraData) {
        return Shadow.of(children.map((child) => typeof child === "string" ? text(child) : child), style, mode, externalId, serializationId, extraData);
    }
    h.shadow = shadow;
    function type(name, publicId, systemId, externalId, serializationId, extraData) {
        return Type.of(name, Option.from(publicId), Option.from(systemId), externalId, serializationId, extraData);
    }
    h.type = type;
    function fragment(children, externalId, extraData) {
        return Fragment.of(children.map((child) => typeof child === "string" ? text(child) : child), externalId, extraData);
    }
    h.fragment = fragment;
    function sheet(rules, disabled, condition) {
        return Sheet.of(rules, disabled, Option.from(condition));
    }
    h.sheet = sheet;
    function block(declarations) {
        return Block.of(Array.isArray(declarations)
            ? declarations
            : entries(declarations).map(([name, value]) => {
                const important = value.endsWith("!important");
                value = value.replace(/!important$/, "").trim();
                // Hyphenate the declaration name unless it's the name of a custom
                // property; these we keep as-is.
                if (!name.startsWith("--")) {
                    name = hyphenate(name);
                }
                return Declaration.of(name, value, important);
            }));
    }
    h.block = block;
    function declaration(name, value, important) {
        return Declaration.of(name, value, important);
    }
    h.declaration = declaration;
    let rule;
    (function (rule) {
        function fontFace(declarations) {
            return FontFaceRule.of(block(declarations));
        }
        rule.fontFace = fontFace;
        function importRule(url, sheet, mediaCondition, supportCondition, 
        // Use "" for anonymous layer.
        layer) {
            return ImportRule.of(url, sheet, Option.from(mediaCondition), Option.from(supportCondition), Option.from(layer));
        }
        rule.importRule = importRule;
        function keyframe(key, declarations) {
            return KeyframeRule.of(key, block(declarations));
        }
        rule.keyframe = keyframe;
        function keyframes(name, rules) {
            return KeyframesRule.of(name, rules);
        }
        rule.keyframes = keyframes;
        function layerBlock(rules, layer) {
            return Layer.BlockRule.of(rules, layer);
        }
        rule.layerBlock = layerBlock;
        function layerStatement(layers) {
            return Layer.StatementRule.of(layers);
        }
        rule.layerStatement = layerStatement;
        function media(condition, rules) {
            return MediaRule.of(condition, rules);
        }
        rule.media = media;
        function namespace(namespace, prefix) {
            return NamespaceRule.of(namespace, Option.from(prefix));
        }
        rule.namespace = namespace;
        function page(selector, declarations) {
            return PageRule.of(selector, block(declarations));
        }
        rule.page = page;
        function style(selector, declarations, hint) {
            return StyleRule.of(selector, block(declarations), hint);
        }
        rule.style = style;
        function supports(condition, rules) {
            return SupportsRule.of(condition, rules);
        }
        rule.supports = supports;
    })(rule = h.rule || (h.rule = {}));
})(h || (h = {}));
function hyphenate(value) {
    return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
}
function defaultNamespace(name) {
    switch (name) {
        // The <a> element exists both in SVG and HTML namespaces.
        // It is defaulted in the HTML namespace and must be explicitly built in
        // the SVG one if needed.
        case "circle":
        case "ellipse":
        case "foreignObject":
        case "g":
        case "image":
        case "line":
        case "mesh":
        case "path":
        case "polygon":
        case "polyline":
        case "rect":
        case "svg":
        case "symbol":
        case "text":
        case "textPath":
        case "use":
            return Namespace.SVG;
        case "annotation":
        case "annotation-xml":
        case "maction":
        case "math":
        case "merror":
        case "mfrac":
        case "mi":
        case "mmultiscripts":
        case "mn":
        case "mo":
        case "mover":
        case "mpadded":
        case "mphantom":
        case "mprescripts":
        case "mroot":
        case "mrow":
        case "ms":
        case "mspace":
        case "msqrt":
        case "mstyle":
        case "msub":
        case "msubsup":
        case "msup":
        case "mtable":
        case "mtd":
        case "mtext":
        case "mtr":
        case "munder":
        case "munderover":
        case "none":
        case "semantics":
            return Namespace.MathML;
        default:
            return Namespace.HTML;
    }
}
//# sourceMappingURL=h.js.map