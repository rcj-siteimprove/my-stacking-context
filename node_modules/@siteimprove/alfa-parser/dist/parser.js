import { Array } from "@siteimprove/alfa-array";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Err, Ok, Result } from "@siteimprove/alfa-result";
const { not } = Predicate;
/**
 * @public
 */
export var Parser;
(function (Parser) {
    function toParser(infallible) {
        return (input, ...args) => Result.of(infallible(input, ...args));
    }
    Parser.toParser = toParser;
    function map(parser, mapper) {
        return (input, ...args) => parser(input, ...args).map(([remainder, value]) => [
            remainder,
            mapper(value),
        ]);
    }
    Parser.map = map;
    function mapResult(parser, mapper) {
        return (input, ...args) => parser(input, ...args).flatMap(([remainder, value]) => mapper(value).map((result) => [remainder, result]));
    }
    Parser.mapResult = mapResult;
    function flatMap(parser, mapper) {
        return (input, ...args) => parser(input, ...args).flatMap(([remainder, value]) => mapper(value)(remainder, ...args));
    }
    Parser.flatMap = flatMap;
    function filter(parser, predicate, ifError) {
        return mapResult(parser, (value) => predicate(value) ? Result.of(value) : Err.of(ifError(value)));
    }
    Parser.filter = filter;
    function reject(parser, predicate, ifError) {
        return filter(parser, not(predicate), ifError);
    }
    Parser.reject = reject;
    function zeroOrMore(parser) {
        return takeAtLeast(parser, 0);
    }
    Parser.zeroOrMore = zeroOrMore;
    function oneOrMore(parser) {
        // The result contains at least one token, so this cast is safe
        return takeAtLeast(parser, 1);
    }
    Parser.oneOrMore = oneOrMore;
    function take(parser, count) {
        return takeBetween(parser, count, count);
    }
    Parser.take = take;
    function takeBetween(parser, lower, upper) {
        return (input, ...args) => {
            const values = [];
            let value;
            for (let i = 0; i < upper; i++) {
                const result = parser(input, ...args);
                if (result.isOk()) {
                    [input, value] = result.get();
                    values.push(value);
                }
                else if (result.isErr()) {
                    if (values.length < lower) {
                        return result;
                    }
                    else {
                        break;
                    }
                }
            }
            return Result.of([input, values]);
        };
    }
    Parser.takeBetween = takeBetween;
    function takeAtLeast(parser, lower) {
        return takeBetween(parser, lower, Infinity);
    }
    Parser.takeAtLeast = takeAtLeast;
    function takeAtMost(parser, upper) {
        return takeBetween(parser, 0, upper);
    }
    Parser.takeAtMost = takeAtMost;
    function takeUntil(parser, condition) {
        return (input, ...args) => {
            const values = [];
            let value;
            while (true) {
                if (condition(input, ...args).isOk()) {
                    return Result.of([input, values]);
                }
                const result = parser(input, ...args);
                if (result.isOk()) {
                    [input, value] = result.get();
                    values.push(value);
                }
                else if (result.isErr()) {
                    return result;
                }
            }
        };
    }
    Parser.takeUntil = takeUntil;
    function peek(parser) {
        return (input, ...args) => parser(input, ...args).map(([, value]) => [input, value]);
    }
    Parser.peek = peek;
    function tee(parser, callback) {
        return (input, ...args) => parser(input, ...args).tee(([remainder, result]) => {
            callback(result, remainder, ...args);
        });
    }
    Parser.tee = tee;
    function teeErr(parser, callback) {
        return (input, ...args) => parser(input, ...args).teeErr((err) => {
            callback(err, ...args);
        });
    }
    Parser.teeErr = teeErr;
    function option(parser) {
        return (input, ...args) => {
            const result = parser(input, ...args);
            if (result.isOk()) {
                const [input, value] = result.get();
                return Result.of([input, Option.of(value)]);
            }
            return Result.of([input, None]);
        };
    }
    Parser.option = option;
    function either(...parsers) {
        return (input, ...args) => {
            let error;
            for (const parser of parsers) {
                const result = parser(input, ...args);
                if (result.isErr()) {
                    error = result;
                }
                else {
                    return result;
                }
            }
            // Per the function overloads, there will always be at least one parser
            // specified. It is therefore safe to assert that if we get this far, at
            // least one parser will have produced an error.
            return error;
        };
    }
    Parser.either = either;
    function pair(left, right) {
        return flatMap(left, (left) => map(right, (right) => [left, right]));
    }
    Parser.pair = pair;
    function left(left, right) {
        return flatMap(left, (left) => map(right, () => left));
    }
    Parser.left = left;
    function right(left, right) {
        return flatMap(left, () => map(right, (right) => right));
    }
    Parser.right = right;
    function delimited(left, parser, right = left) {
        return flatMap(left, () => flatMap(parser, (parser) => map(right, () => parser)));
    }
    Parser.delimited = delimited;
    function separated(left, separator, right = left) {
        return flatMap(left, (left) => flatMap(separator, () => map(right, (right) => [left, right])));
    }
    Parser.separated = separated;
    /**
     * Parse a separated list containing at least one item
     *
     * @param parser - Parser for the items in the list
     * @param separator - Parser for the separator between items
     * @param lower - Minimum number of items to parse, defaults to 1
     * @param upper - Maximum number of items to parse, defaults to Infinity
     */
    function separatedList(parser, separator, lower = 1, upper = Infinity) {
        return map(pair(parser, takeBetween(right(separator, parser), Math.max(0, lower - 1), Math.min(Infinity, upper - 1))), ([first, rest]) => Array.prepend(rest, first));
    }
    Parser.separatedList = separatedList;
    function parseIf(refinement, parser, ifError) {
        return (input, ...args) => parser(input, ...args).flatMap(([rest, result]) => refinement(result)
            ? Ok.of([rest, result])
            : Err.of(ifError(result)));
    }
    Parser.parseIf = parseIf;
    function end(ifError) {
        return (input) => {
            for (const value of input) {
                return Err.of(ifError(value));
            }
            return Result.of([input, undefined]);
        };
    }
    Parser.end = end;
    /**
     * @deprecated Use `end()`
     */
    Parser.eof = end;
})(Parser || (Parser = {}));
//# sourceMappingURL=parser.js.map