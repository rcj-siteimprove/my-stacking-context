import { Array } from "@siteimprove/alfa-array";
import { Comparable } from "@siteimprove/alfa-comparable";
import { Equatable } from "@siteimprove/alfa-equatable";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { Option, None } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
const { not } = Predicate;
const { compareComparable } = Comparable;
/**
 * @public
 */
export class Slice {
    static of(array, start = 0, end = array.length) {
        start = clamp(start, array.length);
        return new Slice(array, start, clamp(end, array.length) - start);
    }
    static _empty = new Slice([], 0, 0);
    static empty() {
        return this._empty;
    }
    _array;
    _offset;
    _length;
    constructor(array, offset, length) {
        this._array = array;
        this._offset = offset;
        this._length = length;
    }
    get length() {
        return this._length;
    }
    get size() {
        return this._length;
    }
    isEmpty() {
        return this._length === 0;
    }
    forEach(callback) {
        Iterable.forEach(this, callback);
    }
    map(mapper) {
        const result = Array.allocate(this._length);
        for (let i = 0, n = this._length; i < n; i++) {
            result[i] = mapper(this._array[this._offset + i], i);
        }
        return new Slice(result, 0, result.length);
    }
    apply(mapper) {
        const array = [...Iterable.apply(this, mapper)];
        return new Slice(array, 0, array.length);
    }
    flatMap(mapper) {
        const array = [...Iterable.flatMap(this, mapper)];
        return new Slice(array, 0, array.length);
    }
    flatten() {
        return this.flatMap((slice) => slice);
    }
    reduce(reducer, accumulator) {
        return Iterable.reduce(this, reducer, accumulator);
    }
    reduceWhile(predicate, reducer, accumulator) {
        return Iterable.reduceWhile(this, predicate, reducer, accumulator);
    }
    reduceUntil(predicate, reducer, accumulator) {
        return Iterable.reduceUntil(this, predicate, reducer, accumulator);
    }
    filter(predicate) {
        const array = [...Iterable.filter(this, predicate)];
        return new Slice(array, 0, array.length);
    }
    reject(predicate) {
        const array = [...Iterable.reject(this, predicate)];
        return new Slice(array, 0, array.length);
    }
    find(predicate) {
        return Iterable.find(this, predicate);
    }
    includes(value) {
        return Iterable.includes(this, value);
    }
    collect(mapper) {
        const array = [...Iterable.collect(this, mapper)];
        return new Slice(array, 0, array.length);
    }
    collectFirst(mapper) {
        return Iterable.collectFirst(this, mapper);
    }
    some(predicate) {
        return Iterable.some(this, predicate);
    }
    none(predicate) {
        return Iterable.none(this, predicate);
    }
    every(predicate) {
        return Iterable.every(this, predicate);
    }
    count(predicate) {
        return Iterable.count(this, predicate);
    }
    distinct() {
        const array = [...Iterable.distinct(this)];
        return new Slice(array, 0, array.length);
    }
    get(index) {
        if (index < 0 || index >= this._length) {
            return None;
        }
        return Option.of(this._array[this._offset + index]);
    }
    has(index) {
        return index < 0 || index >= this._length;
    }
    set(index, value) {
        if (index < 0 || index >= this._length) {
            return this;
        }
        const array = this.toArray();
        array[index] = value;
        return new Slice(array, 0, array.length);
    }
    insert(index, value) {
        const array = Array.insert(this.toArray(), index, value);
        return new Slice(array, 0, array.length);
    }
    append(value) {
        const array = Array.append(this.toArray(), value);
        return new Slice(array, 0, array.length);
    }
    prepend(value) {
        const array = Array.prepend(this.toArray(), value);
        return new Slice(array, 0, array.length);
    }
    concat(iterable) {
        const array = this.toArray();
        for (const value of iterable) {
            array.push(value);
        }
        return new Slice(array, 0, array.length);
    }
    subtract(iterable) {
        const array = [...Iterable.subtract(this, iterable)];
        return new Slice(array, 0, array.length);
    }
    intersect(iterable) {
        const array = [...Iterable.intersect(this, iterable)];
        return new Slice(array, 0, array.length);
    }
    tee(callback, ...args) {
        callback(this, ...args);
        return this;
    }
    zip(iterable) {
        const array = [...Iterable.zip(this, iterable)];
        return new Slice(array, 0, array.length);
    }
    first() {
        return this.get(0);
    }
    last() {
        return this.get(this._length - 1);
    }
    take(count) {
        return this.slice(0, count);
    }
    takeWhile(predicate) {
        let count = 0;
        for (let i = 0, n = this._length; i < n; i++) {
            if (predicate(this._array[this._offset + i], i)) {
                count++;
            }
            else {
                break;
            }
        }
        return this.take(count);
    }
    takeUntil(predicate) {
        return this.takeWhile(not(predicate));
    }
    takeLast(count) {
        return this.slice(this._length - count);
    }
    takeLastWhile(predicate) {
        let count = 0;
        for (let i = this._length - 1; i >= 0; i--) {
            if (predicate(this._array[this._offset + i], i)) {
                count++;
            }
            else {
                break;
            }
        }
        return this.takeLast(count);
    }
    takeLastUntil(predicate) {
        return this.takeLastWhile(not(predicate));
    }
    skip(count) {
        return this.slice(count);
    }
    skipWhile(predicate) {
        let count = 0;
        for (let i = 0, n = this._length; i < n; i++) {
            if (predicate(this._array[this._offset + i], i)) {
                count++;
            }
            else {
                break;
            }
        }
        return this.skip(count);
    }
    skipUntil(predicate) {
        return this.skipWhile(not(predicate));
    }
    skipLast(count) {
        return this.slice(0, this._length - count);
    }
    skipLastWhile(predicate) {
        let count = 0;
        for (let i = this._length - 1; i >= 0; i--) {
            if (predicate(this._array[this._offset + i], i)) {
                count++;
            }
            else {
                break;
            }
        }
        return this.skipLast(count);
    }
    skipLastUntil(predicate) {
        return this.skipLastWhile(not(predicate));
    }
    trim(predicate) {
        return this.trimLeading(predicate).trimTrailing(predicate);
    }
    trimLeading(predicate) {
        return this.skipWhile(predicate);
    }
    trimTrailing(predicate) {
        return this.skipLastWhile(predicate);
    }
    rest() {
        return this.slice(1);
    }
    slice(start, end = this._length) {
        start = clamp(start, this._length);
        return new Slice(this._array, this._offset + start, clamp(end, this._length) - start);
    }
    reverse() {
        const array = this.toArray().reverse();
        return new Slice(array, 0, array.length);
    }
    join(separator) {
        return Iterable.join(this, separator);
    }
    sort() {
        return this.sortWith(compareComparable);
    }
    sortWith(comparer) {
        const array = Array.sortWith(this.toArray(), comparer);
        return new Slice(array, 0, array.length);
    }
    compare(iterable) {
        return this.compareWith(iterable, compareComparable);
    }
    compareWith(iterable, comparer) {
        return Iterable.compareWith(this, iterable, comparer);
    }
    *iterator() {
        for (let i = this._offset, n = i + this._length; i < n; i++) {
            yield this._array[i];
        }
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    equals(value) {
        if (value instanceof Slice && value._length === this._length) {
            for (let i = 0, n = value._length; i < n; i++) {
                if (!Equatable.equals(value._array[value._offset + i], this._array[this._offset + i])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    hash(hash) {
        Iterable.hash(this, hash);
    }
    toArray() {
        return this._array.slice(this._offset, this._offset + this._length);
    }
    toJSON(options) {
        return this.toArray().map((value) => Serializable.toJSON(value, options));
    }
    toString() {
        const values = this.toArray().join(", ");
        return `Slice [${values === "" ? "" : ` ${values} `}]`;
    }
}
/**
 * @public
 */
(function (Slice) {
    function from(iterable) {
        if (isSlice(iterable)) {
            return iterable;
        }
        return Slice.of([...iterable]);
    }
    Slice.from = from;
    function isSlice(value) {
        return value instanceof Slice;
    }
    Slice.isSlice = isSlice;
})(Slice || (Slice = {}));
function clamp(value, length) {
    return value < 0 ? 0 : value > length ? length : value;
}
//# sourceMappingURL=slice.js.map