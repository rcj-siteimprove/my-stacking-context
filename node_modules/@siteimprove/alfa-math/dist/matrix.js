import { Real } from "./real.js";
/**
 * @public
 */
export var Matrix;
(function (Matrix) {
    function isMatrix(value) {
        return (Array.isArray(value) &&
            value.every((r) => Array.isArray(r) && r.every((v) => typeof v === "number")));
    }
    Matrix.isMatrix = isMatrix;
    function isSquare(m) {
        return rows(m) === columns(m);
    }
    Matrix.isSquare = isSquare;
    function clone(m) {
        return m.map((r) => r.slice(0));
    }
    Matrix.clone = clone;
    function equals(m, n, e) {
        return (m.length === n.length &&
            m.every((r, i) => r.length === n[i].length &&
                r.every((v, j) => Real.equals(v, n[i][j], e))));
    }
    Matrix.equals = equals;
    function identity(n) {
        return new Array(n).fill([]).map((_, i) => {
            const r = new Array(n).fill(0);
            r[i] = 1;
            return r;
        });
    }
    Matrix.identity = identity;
    function size(m) {
        return [rows(m), columns(m)];
    }
    Matrix.size = size;
    function rows(m) {
        return m.length;
    }
    Matrix.rows = rows;
    function columns(m) {
        return m.length === 0 ? 0 : m[0].length;
    }
    Matrix.columns = columns;
    function row(m, i) {
        return m[i];
    }
    Matrix.row = row;
    function column(m, i) {
        return m.map((r) => r[i]);
    }
    Matrix.column = column;
    function add(m, n) {
        return m.map((r, i) => r.map((v, j) => v + n?.[i]?.[j]));
    }
    Matrix.add = add;
    function subtract(m, n) {
        return m.map((r, i) => r.map((v, j) => v - n?.[i]?.[j]));
    }
    Matrix.subtract = subtract;
    /**
     * {@link https://en.wikipedia.org/wiki/Matrix_multiplication}
     */
    function multiply(m, n) {
        return typeof n === "number"
            ? m.map((r) => r.map((v) => v * n))
            : m.map((r, i) => n[0].map((_, j) => r.reduce((s, _, k) => s + m[i][k] * n?.[k]?.[j], 0)));
    }
    Matrix.multiply = multiply;
    /**
     * Compute the transpose of a matrix.
     *
     * {@link https://en.wikipedia.org/wiki/Transpose}
     */
    function transpose(m) {
        return m.length === 0 ? m : m[0].map((_, i) => m.map((row) => row[i]));
    }
    Matrix.transpose = transpose;
    /**
     * Compute the determinant of a non-empty, square matrix.
     *
     * {@link https://en.wikipedia.org/wiki/Determinant}
     * {@link https://en.wikipedia.org/wiki/Laplace_expansion}
     *
     * @remarks
     * This function uses Laplace expansion for computing the determinant which
     * has a time complexity of O(n!) and is therefore not practical for large
     * matrices.
     */
    function determinant(m) {
        switch (m.length) {
            // The determinant of a 1x1 matrix is the single value of the matrix.
            case 1:
                return m[0][0];
            // The determinant of a 2x2 matrix is fairly short to write out and so
            // this is done as an optimization.
            case 2:
                return m[0]?.[0] * m[1]?.[1] - m[0]?.[1] * m[1]?.[0];
            default:
                return m.reduce((d, _, i) => d + m[0]?.[i] * cofactor(m, 0, i), 0);
        }
    }
    Matrix.determinant = determinant;
    /**
     * Compute the inverse of an invertible matrix.
     *
     * {@link https://en.wikipedia.org/wiki/Invertible_matrix}
     * {@link https://en.wikipedia.org/wiki/Cramers_rule}
     *
     * @remarks
     * This function uses Cramer's rule for computing the inverse which has a time
     * complexity of O(n!) and is therefore not practical for large matrices.
     */
    function inverse(m) {
        return multiply(adjugate(m), 1 / determinant(m));
    }
    Matrix.inverse = inverse;
    /**
     * Compute the (i, j) cofactor of a non-empty, square matrix.
     *
     * {@link https://en.wikipedia.org/wiki/Minor_(linear_algebra)}
     * @internal
     */
    function cofactor(m, i, j) {
        return (-1) ** (i + j) * minor(m, i, j);
    }
    /**
     * Compute the (i, j) minor of a non-empty, square matrix.
     *
     * {@link https://en.wikipedia.org/wiki/Minor_(linear_algebra)}
     * @internal
     */
    function minor(m, i, j) {
        return determinant(m
            // Remove the i-th row
            .filter((_, k) => k !== i)
            .map((r) => r
            // Remove the j-th column
            .filter((_, l) => l !== j)));
    }
    /**
     * Compute the adjugate of a non-empty, square matrix.
     *
     * {@link https://en.wikipedia.org/wiki/Adjugate_matrix}
     * @internal
     */
    function adjugate(m) {
        return transpose(m.map((r, i) => r.map((_, j) => cofactor(m, i, j))));
    }
})(Matrix || (Matrix = {}));
//# sourceMappingURL=matrix.js.map