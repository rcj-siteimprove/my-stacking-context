import { Array } from "@siteimprove/alfa-array";
import { Comparable } from "@siteimprove/alfa-comparable";
import { Equatable } from "@siteimprove/alfa-equatable";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { Lazy } from "@siteimprove/alfa-lazy";
import { Map } from "@siteimprove/alfa-map";
import { None, Option } from "@siteimprove/alfa-option";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Set } from "@siteimprove/alfa-set";
import { Sequence } from "./sequence.js";
import { Nil } from "./nil.js";
const { not, equals } = Predicate;
const { compareComparable } = Comparable;
/**
 * @public
 */
export class Cons {
    static of(head, tail = Lazy.force(Nil)) {
        return new Cons(head, tail);
    }
    _head;
    _tail;
    constructor(head, tail) {
        this._head = head;
        this._tail = tail;
    }
    get size() {
        return Iterable.size(this);
    }
    isEmpty() {
        return false;
    }
    forEach(callback) {
        Iterable.forEach(this, callback);
    }
    map(mapper, index = 0) {
        return new Cons(mapper(this._head, index), this._tail.map((tail) => Cons.isCons(tail) ? tail.map(mapper, index + 1) : Nil));
    }
    apply(mapper) {
        return mapper.flatMap((mapper) => this.map(mapper));
    }
    flatMap(mapper, index = 0) {
        let next = this;
        while (true) {
            const head = mapper(next._head, index++);
            if (Cons.isCons(head)) {
                return new Cons(head._head, head._tail.map((left) => {
                    const right = next._tail.force();
                    return Cons.isCons(right)
                        ? left.concat(right.flatMap(mapper, index))
                        : left;
                }));
            }
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return Nil;
            }
        }
    }
    flatten() {
        return this.flatMap((sequence) => sequence);
    }
    reduce(reducer, accumulator) {
        let next = this;
        let index = 0;
        while (true) {
            accumulator = reducer(accumulator, next._head, index++);
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                break;
            }
        }
        return accumulator;
    }
    reduceWhile(predicate, reducer, accumulator) {
        let next = this;
        let index = 0;
        while (predicate(next._head, index)) {
            accumulator = reducer(accumulator, next._head, index++);
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                break;
            }
        }
        return accumulator;
    }
    reduceUntil(predicate, reducer, accumulator) {
        return this.reduceWhile(not(predicate), reducer, accumulator);
    }
    filter(predicate, index = 0) {
        let next = this;
        while (true) {
            if (predicate(next._head, index++)) {
                return new Cons(next._head, next._tail.map((tail) => Cons.isCons(tail) ? tail.filter(predicate, index) : Nil));
            }
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return Nil;
            }
        }
    }
    reject(predicate) {
        return this.filter(not(predicate));
    }
    find(predicate) {
        let next = this;
        let index = 0;
        while (true) {
            const head = next._head;
            if (predicate(head, index++)) {
                return Option.of(head);
            }
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return None;
            }
        }
    }
    includes(value) {
        return this.some(equals(value));
    }
    collect(mapper, index = 0) {
        let next = this;
        while (true) {
            const value = mapper(next._head, index++);
            if (value.isSome()) {
                return new Cons(value.get(), next._tail.map((tail) => Cons.isCons(tail) ? tail.collect(mapper, index) : Nil));
            }
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return Nil;
            }
        }
    }
    collectFirst(mapper) {
        let next = this;
        let index = 0;
        while (true) {
            const value = mapper(next._head, index++);
            if (value.isSome()) {
                return value;
            }
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return None;
            }
        }
    }
    some(predicate) {
        let next = this;
        let index = 0;
        while (true) {
            if (predicate(next._head, index++)) {
                return true;
            }
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return false;
            }
        }
    }
    none(predicate) {
        return this.every(not(predicate));
    }
    every(predicate) {
        let next = this;
        let index = 0;
        while (true) {
            if (!predicate(next._head, index++)) {
                return false;
            }
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return true;
            }
        }
    }
    count(predicate) {
        return this.reduce((count, value, index) => (predicate(value, index) ? count + 1 : count), 0);
    }
    distinct(seen = Set.empty()) {
        let next = this;
        while (true) {
            if (seen.has(next._head)) {
                const tail = next._tail.force();
                if (Cons.isCons(tail)) {
                    next = tail;
                }
                else {
                    return Nil;
                }
            }
            else {
                return Cons.of(next._head, next._tail.map((tail) => Cons.isCons(tail) ? tail.distinct(seen.add(next._head)) : Nil));
            }
        }
    }
    get(index) {
        return index < 0 ? None : this.skip(index).first();
    }
    has(index) {
        return this.get(index).isSome();
    }
    set(index, value) {
        if (index < 0) {
            return this;
        }
        if (index === 0) {
            if (Equatable.equals(value, this._head)) {
                return this;
            }
            return new Cons(value, this._tail);
        }
        return new Cons(this._head, this._tail.map((tail) => tail.set(index - 1, value)));
    }
    insert(index, value) {
        if (index < 0) {
            return this;
        }
        if (index === 0) {
            return new Cons(value, Lazy.force(this));
        }
        return new Cons(this._head, this._tail.map((tail) => tail.set(index - 1, value)));
    }
    append(value) {
        return new Cons(this._head, this._tail.map((tail) => tail.append(value)));
    }
    prepend(value) {
        return new Cons(value, Lazy.force(this));
    }
    concat(iterable) {
        const sequence = Sequence.from(iterable);
        if (Cons.isCons(sequence)) {
            return new Cons(this._head, this._tail.map((tail) => tail.concat(sequence)));
        }
        return this;
    }
    subtract(iterable) {
        return this.filter((value) => !Iterable.includes(iterable, value));
    }
    intersect(iterable) {
        return this.filter((value) => Iterable.includes(iterable, value));
    }
    tee(callback, ...args) {
        callback(this, ...args);
        return this;
    }
    zip(iterable) {
        const sequence = Sequence.from(iterable);
        if (Cons.isCons(sequence)) {
            return new Cons([this._head, sequence._head], this._tail.map((tail) => tail.zip(sequence.rest())));
        }
        return Nil;
    }
    first() {
        return Option.of(this._head);
    }
    last() {
        let next = this;
        while (true) {
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return Option.of(next._head);
            }
        }
    }
    take(count) {
        if (count <= 0) {
            return Nil;
        }
        return new Cons(this._head, count === 1
            ? Lazy.force(Nil)
            : this._tail.map((tail) => Cons.isCons(tail) ? tail.take(count - 1) : Nil));
    }
    takeWhile(predicate) {
        return this.takeUntil(not(predicate));
    }
    takeUntil(predicate, index = 0) {
        if (predicate(this._head, index)) {
            return Nil;
        }
        return new Cons(this._head, this._tail.map((tail) => Cons.isCons(tail)
            ? tail.takeUntil(predicate, index + 1)
            : tail.takeUntil(predicate)));
    }
    takeLast(count) {
        return this.skip(this.size - count);
    }
    takeLastWhile(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
    }
    takeLastUntil(predicate) {
        return this.takeLastWhile(not(predicate));
    }
    skip(count) {
        let next = this;
        while (count-- > 0) {
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return Nil;
            }
        }
        return next;
    }
    skipWhile(predicate) {
        let next = this;
        let index = 0;
        while (predicate(next._head, index++)) {
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return Nil;
            }
        }
        return next;
    }
    skipUntil(predicate) {
        return this.skipWhile(not(predicate));
    }
    skipLast(count) {
        return this.take(this.size - count);
    }
    skipLastWhile(predicate) {
        return this.reverse().skipWhile(predicate).reverse();
    }
    skipLastUntil(predicate) {
        return this.skipLastWhile(not(predicate));
    }
    trim(predicate) {
        return this.trimLeading(predicate).trimTrailing(predicate);
    }
    trimLeading(predicate) {
        return this.skipWhile(predicate);
    }
    trimTrailing(predicate) {
        return this.skipLastWhile(predicate);
    }
    rest() {
        return this._tail.force();
    }
    slice(start, end) {
        let slice = this.skip(start);
        if (end !== undefined) {
            slice = slice.take(end - start);
        }
        return slice;
    }
    reverse() {
        return this.reduce((reversed, value) => new Cons(value, Lazy.force(reversed)), Nil);
    }
    join(separator) {
        let result = `${this._head}`;
        let next = this;
        while (true) {
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                result += `${separator}${tail._head}`;
                next = tail;
            }
            else {
                return result;
            }
        }
    }
    sort() {
        return this.sortWith(compareComparable);
    }
    sortWith(comparer) {
        return Sequence.fromArray(Array.sortWith(this.toArray(), comparer));
    }
    compare(iterable) {
        return this.compareWith(iterable, Comparable.compare);
    }
    compareWith(iterable, comparer) {
        return Iterable.compareWith(this, iterable, comparer);
    }
    groupBy(grouper) {
        return this.reduce((groups, value, index) => {
            const group = grouper(value, index);
            return groups.set(group, new Cons(value, Lazy.force(groups.get(group).getOrElse(() => Nil))));
        }, Map.empty()).map((group) => group.reverse());
    }
    equals(value) {
        if (!Cons.isCons(value)) {
            return false;
        }
        let a = this;
        let b = value;
        while (true) {
            if (!Equatable.equals(a._head, b._head)) {
                return false;
            }
            const ta = a._tail.force();
            const tb = b._tail.force();
            if (Cons.isCons(ta) && Cons.isCons(tb)) {
                a = ta;
                b = tb;
            }
            else {
                return ta === Nil && tb === Nil;
            }
        }
    }
    hash(hash) {
        let size = 0;
        for (const value of this) {
            hash.writeUnknown(value);
            size++;
        }
        hash.writeUint32(size);
    }
    *iterator() {
        let next = this;
        while (true) {
            yield next._head;
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                break;
            }
        }
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    toArray() {
        const array = [];
        let next = this;
        while (true) {
            array.push(next._head);
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return array;
            }
        }
    }
    toJSON(options) {
        const json = [];
        let next = this;
        while (true) {
            json.push(Serializable.toJSON(next._head, options));
            const tail = next._tail.force();
            if (Cons.isCons(tail)) {
                next = tail;
            }
            else {
                return json;
            }
        }
    }
    toString() {
        return `Sequence [ ${this.join(", ")} ]`;
    }
}
/**
 * @public
 */
(function (Cons) {
    function isCons(value) {
        return value instanceof Cons;
    }
    Cons.isCons = isCons;
})(Cons || (Cons = {}));
//# sourceMappingURL=cons.js.map