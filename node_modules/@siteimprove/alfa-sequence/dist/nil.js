import { Comparable } from "@siteimprove/alfa-comparable";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Map } from "@siteimprove/alfa-map";
import { None } from "@siteimprove/alfa-option";
import { Sequence } from "./sequence.js";
import { Cons } from "./cons.js";
/**
 * @public
 */
export const Nil = new (class Nil {
    get size() {
        return 0;
    }
    isEmpty() {
        return true;
    }
    forEach() { }
    map() {
        return this;
    }
    apply() {
        return this;
    }
    flatMap() {
        return this;
    }
    flatten() {
        return this;
    }
    reduce(reducer, accumulator) {
        return accumulator;
    }
    reduceWhile(predicate, reducer, accumulator) {
        return accumulator;
    }
    reduceUntil(predicate, reducer, accumulator) {
        return accumulator;
    }
    filter() {
        return this;
    }
    reject() {
        return this;
    }
    find() {
        return None;
    }
    includes() {
        return false;
    }
    collect() {
        return this;
    }
    collectFirst() {
        return None;
    }
    some() {
        return false;
    }
    none() {
        return true;
    }
    every() {
        return true;
    }
    count() {
        return 0;
    }
    distinct() {
        return this;
    }
    get() {
        return None;
    }
    has() {
        return false;
    }
    set() {
        return this;
    }
    insert(index, value) {
        return index === 0 ? Cons.of(value) : this;
    }
    append(value) {
        return Cons.of(value);
    }
    prepend(value) {
        return Cons.of(value);
    }
    concat(iterable) {
        if (iterable === this) {
            return this;
        }
        return Sequence.from(iterable);
    }
    subtract() {
        return this;
    }
    intersect() {
        return this;
    }
    tee(callback, ...args) {
        callback(this, ...args);
        return this;
    }
    zip() {
        return this;
    }
    first() {
        return None;
    }
    last() {
        return None;
    }
    take() {
        return this;
    }
    takeWhile() {
        return this;
    }
    takeUntil() {
        return this;
    }
    takeLast() {
        return this;
    }
    takeLastWhile() {
        return this;
    }
    takeLastUntil() {
        return this;
    }
    skip() {
        return this;
    }
    skipWhile() {
        return this;
    }
    skipUntil() {
        return this;
    }
    skipLast() {
        return this;
    }
    skipLastWhile() {
        return this;
    }
    skipLastUntil() {
        return this;
    }
    trim() {
        return this;
    }
    trimLeading() {
        return this;
    }
    trimTrailing() {
        return this;
    }
    rest() {
        return this;
    }
    slice() {
        return this;
    }
    reverse() {
        return this;
    }
    join() {
        return "";
    }
    sort() {
        return this;
    }
    sortWith() {
        return this;
    }
    compare(iterable) {
        return this.compareWith(iterable, Comparable.compare);
    }
    compareWith(iterable, comparer) {
        return Iterable.compareWith(this, iterable, comparer);
    }
    groupBy() {
        return Map.empty();
    }
    equals(value) {
        return value instanceof Nil;
    }
    hash(hash) {
        hash.writeUint32(0);
    }
    *iterator() { }
    [Symbol.iterator]() {
        return this.iterator();
    }
    toArray() {
        return [];
    }
    toJSON() {
        return [];
    }
    toString() {
        return "Sequence []";
    }
})();
//# sourceMappingURL=nil.js.map