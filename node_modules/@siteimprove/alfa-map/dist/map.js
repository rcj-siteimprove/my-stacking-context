import { Array } from "@siteimprove/alfa-array";
import { FNV } from "@siteimprove/alfa-fnv";
import { Iterable } from "@siteimprove/alfa-iterable";
import { Serializable } from "@siteimprove/alfa-json";
import { Predicate } from "@siteimprove/alfa-predicate";
import { Empty } from "./node.js";
const { not } = Predicate;
/**
 * @public
 */
export class Map {
    static of(...entries) {
        return entries.reduce((map, [key, value]) => map.set(key, value), Map.empty());
    }
    static _empty = new Map(Empty, 0);
    static empty() {
        return this._empty;
    }
    _root;
    _size;
    constructor(root, size) {
        this._root = root;
        this._size = size;
    }
    get size() {
        return this._size;
    }
    isEmpty() {
        return this._size === 0;
    }
    forEach(callback) {
        Iterable.forEach(this, ([key, value]) => callback(value, key));
    }
    map(mapper) {
        return new Map(this._root.map(mapper), this._size);
    }
    /**
     * Apply a map of functions to each corresponding value of this map.
     *
     * @remarks
     * Keys without a corresponding function or value are dropped from the
     * resulting map.
     *
     * @example
     * ```ts
     * Map.of(["a", 1], ["b", 2])
     *   .apply(Map.of(["a", (x) => x + 1], ["b", (x) => x * 2]))
     *   .toArray();
     * // => [["a", 2], ["b", 4]]
     * ```
     */
    apply(mapper) {
        return this.collect((value, key) => mapper.get(key).map((mapper) => mapper(value)));
    }
    /**
     * @remarks
     * As the order of maps is undefined, it is also undefined which keys are
     * kept when duplicate keys are encountered.
     */
    flatMap(mapper) {
        return this.reduce((map, value, key) => map.concat(mapper(value, key)), Map.empty());
    }
    /**
     * @remarks
     * As the order of maps is undefined, it is also undefined which keys are
     * kept when duplicate keys are encountered.
     */
    flatten() {
        return this.flatMap((map) => map);
    }
    reduce(reducer, accumulator) {
        return Iterable.reduce(this, (accumulator, [key, value]) => reducer(accumulator, value, key), accumulator);
    }
    filter(predicate) {
        return this.reduce((map, value, key) => (predicate(value, key) ? map.set(key, value) : map), Map.empty());
    }
    reject(predicate) {
        return this.filter(not(predicate));
    }
    find(predicate) {
        return Iterable.find(this, ([key, value]) => predicate(value, key)).map(([, value]) => value);
    }
    includes(value) {
        return Iterable.includes(this.values(), value);
    }
    collect(mapper) {
        return Map.from(Iterable.collect(this, ([key, value]) => mapper(value, key).map((value) => [key, value])));
    }
    collectFirst(mapper) {
        return Iterable.collectFirst(this, ([key, value]) => mapper(value, key));
    }
    some(predicate) {
        return Iterable.some(this, ([key, value]) => predicate(value, key));
    }
    none(predicate) {
        return Iterable.none(this, ([key, value]) => predicate(value, key));
    }
    every(predicate) {
        return Iterable.every(this, ([key, value]) => predicate(value, key));
    }
    count(predicate) {
        return Iterable.count(this, ([key, value]) => predicate(value, key));
    }
    /**
     * @remarks
     * As the order of maps is undefined, it is also undefined which keys are
     * kept when duplicate values are encountered.
     */
    distinct() {
        let seen = Map.empty();
        // We optimize for the case where there are more distinct values than there
        // are duplicate values by starting with the current map and removing
        // duplicates as we find them.
        let map = this;
        for (const [key, value] of map) {
            if (seen.has(value)) {
                map = map.delete(key);
            }
            else {
                seen = seen.set(value, value);
            }
        }
        return map;
    }
    get(key) {
        return this._root.get(key, hash(key), 0);
    }
    has(key) {
        return this.get(key).isSome();
    }
    set(key, value) {
        const { result: root, status } = this._root.set(key, value, hash(key), 0);
        if (status === "unchanged") {
            return this;
        }
        return new Map(root, this._size + (status === "updated" ? 0 : 1));
    }
    delete(key) {
        const { result: root, status } = this._root.delete(key, hash(key), 0);
        if (status === "unchanged") {
            return this;
        }
        return new Map(root, this._size - 1);
    }
    concat(iterable) {
        return Iterable.reduce(iterable, (map, [key, value]) => map.set(key, value), this);
    }
    subtract(iterable) {
        return Iterable.reduce(iterable, (map, [key]) => map.delete(key), this);
    }
    intersect(iterable) {
        return Map.fromIterable(Iterable.filter(iterable, ([key]) => this.has(key)));
    }
    tee(callback, ...args) {
        callback(this, ...args);
        return this;
    }
    equals(value) {
        return (value instanceof Map &&
            value._size === this._size &&
            value._root.equals(this._root));
    }
    hash(hash) {
        for (const [key, value] of this) {
            hash.writeUnknown(key).writeUnknown(value);
        }
        hash.writeUint32(this._size);
    }
    keys() {
        return Iterable.map(this._root, (entry) => entry[0]);
    }
    values() {
        return Iterable.map(this._root, (entry) => entry[1]);
    }
    *iterator() {
        yield* this._root;
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    toArray() {
        return [...this];
    }
    toJSON(options) {
        return this.toArray().map(([key, value]) => [
            Serializable.toJSON(key, options),
            Serializable.toJSON(value, options),
        ]);
    }
    toString() {
        const entries = this.toArray()
            .map(([key, value]) => `${key} => ${value}`)
            .join(", ");
        return `Map {${entries === "" ? "" : ` ${entries} `}}`;
    }
}
/**
 * @public
 */
(function (Map) {
    function isMap(value) {
        return value instanceof Map;
    }
    Map.isMap = isMap;
    function from(iterable) {
        if (isMap(iterable)) {
            return iterable;
        }
        if (Array.isArray(iterable)) {
            return fromArray(iterable);
        }
        return fromIterable(iterable);
    }
    Map.from = from;
    function fromArray(array) {
        return Array.reduce(array, (map, [key, value]) => map.set(key, value), Map.empty());
    }
    Map.fromArray = fromArray;
    function fromIterable(iterable) {
        return Iterable.reduce(iterable, (map, [key, value]) => map.set(key, value), Map.empty());
    }
    Map.fromIterable = fromIterable;
})(Map || (Map = {}));
function hash(key) {
    return FNV.empty().writeUnknown(key).finish();
}
//# sourceMappingURL=map.js.map