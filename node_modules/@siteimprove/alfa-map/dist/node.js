import { Bits } from "@siteimprove/alfa-bits";
import { Equatable } from "@siteimprove/alfa-equatable";
import { None, Option } from "@siteimprove/alfa-option";
import { Status } from "./status.js";
const { bit, take, skip, test, set, clear, popCount } = Bits;
/**
 * @internal
 */
export var Node;
(function (Node) {
    Node.Bits = 5;
    function fragment(hash, shift) {
        return take(skip(hash, shift), Node.Bits);
    }
    Node.fragment = fragment;
    function index(fragment, mask) {
        return popCount(take(mask, fragment));
    }
    Node.index = index;
})(Node || (Node = {}));
/**
 * @internal
 */
export const Empty = new (class Empty {
    isEmpty() {
        return true;
    }
    isLeaf() {
        return false;
    }
    get() {
        return None;
    }
    set(key, value, hash) {
        return Status.created(Leaf.of(hash, key, value));
    }
    delete() {
        return Status.unchanged(this);
    }
    map() {
        return this;
    }
    equals(value) {
        return value instanceof Empty;
    }
    *[Symbol.iterator]() { }
})();
/**
 * @internal
 */
export class Leaf {
    static of(hash, key, value) {
        return new Leaf(hash, key, value);
    }
    _hash;
    _key;
    _value;
    constructor(hash, key, value) {
        this._hash = hash;
        this._key = key;
        this._value = value;
    }
    get key() {
        return this._key;
    }
    get value() {
        return this._value;
    }
    isEmpty() {
        return false;
    }
    isLeaf() {
        return true;
    }
    get(key, hash, shift) {
        return hash === this._hash && Equatable.equals(key, this._key)
            ? Option.of(this._value)
            : None;
    }
    set(key, value, hash, shift) {
        if (hash === this._hash) {
            if (Equatable.equals(key, this._key)) {
                if (Equatable.equals(value, this._value)) {
                    return Status.unchanged(this);
                }
                return Status.updated(Leaf.of(hash, key, value));
            }
            return Status.created(Collision.of(hash, [this, Leaf.of(hash, key, value)]));
        }
        const fragment = Node.fragment(this._hash, shift);
        return Sparse.of(bit(fragment), [this]).set(key, value, hash, shift);
    }
    delete(key, hash) {
        return hash === this._hash && Equatable.equals(key, this._key)
            ? Status.deleted(Empty)
            : Status.unchanged(this);
    }
    map(mapper) {
        return Leaf.of(this._hash, this._key, mapper(this._value, this._key));
    }
    equals(value) {
        return (value instanceof Leaf &&
            value._hash === this._hash &&
            Equatable.equals(value._key, this._key) &&
            Equatable.equals(value._value, this._value));
    }
    *[Symbol.iterator]() {
        yield [this._key, this._value];
    }
}
/**
 * @internal
 */
export class Collision {
    static of(hash, nodes) {
        return new Collision(hash, nodes);
    }
    _hash;
    _nodes;
    constructor(hash, nodes) {
        this._hash = hash;
        this._nodes = nodes;
    }
    isEmpty() {
        return false;
    }
    isLeaf() {
        return false;
    }
    get(key, hash, shift) {
        if (hash === this._hash) {
            for (const node of this._nodes) {
                const value = node.get(key, hash, shift);
                if (value.isSome()) {
                    return value;
                }
            }
        }
        return None;
    }
    set(key, value, hash, shift) {
        if (hash === this._hash) {
            for (let i = 0, n = this._nodes.length; i < n; i++) {
                const node = this._nodes[i];
                if (Equatable.equals(key, node.key)) {
                    if (Equatable.equals(value, node.value)) {
                        return Status.unchanged(this);
                    }
                    return Status.updated(Collision.of(this._hash, replace(this._nodes, i, Leaf.of(hash, key, value))));
                }
            }
            return Status.created(Collision.of(this._hash, this._nodes.concat(Leaf.of(hash, key, value))));
        }
        const fragment = Node.fragment(this._hash, shift);
        return Sparse.of(bit(fragment), [this]).set(key, value, hash, shift);
    }
    delete(key, hash) {
        if (hash === this._hash) {
            for (let i = 0, n = this._nodes.length; i < n; i++) {
                const node = this._nodes[i];
                if (Equatable.equals(key, node.key)) {
                    const nodes = remove(this._nodes, i);
                    if (nodes.length === 1) {
                        // We just deleted the penultimate Leaf of the Collision, so we can
                        // remove the Collision and only keep the remaining Leaf.
                        return Status.deleted(nodes[0]);
                    }
                    return Status.deleted(Collision.of(this._hash, nodes));
                }
            }
        }
        return Status.unchanged(this);
    }
    map(mapper) {
        return Collision.of(this._hash, this._nodes.map((node) => node.map(mapper)));
    }
    equals(value) {
        return (value instanceof Collision &&
            value._hash === this._hash &&
            value._nodes.length === this._nodes.length &&
            value._nodes.every((node, i) => node.equals(this._nodes[i])));
    }
    *[Symbol.iterator]() {
        for (const node of this._nodes) {
            yield* node;
        }
    }
}
/**
 * @internal
 */
export class Sparse {
    static of(mask, nodes) {
        return new Sparse(mask, nodes);
    }
    _mask;
    _nodes;
    constructor(mask, nodes) {
        this._mask = mask;
        this._nodes = nodes;
    }
    isEmpty() {
        return false;
    }
    isLeaf() {
        return false;
    }
    get(key, hash, shift) {
        const fragment = Node.fragment(hash, shift);
        if (test(this._mask, fragment)) {
            const index = Node.index(fragment, this._mask);
            return this._nodes[index].get(key, hash, shift + Node.Bits);
        }
        return None;
    }
    set(key, value, hash, shift) {
        const fragment = Node.fragment(hash, shift);
        const index = Node.index(fragment, this._mask);
        if (test(this._mask, fragment)) {
            const { result: node, status } = this._nodes[index].set(key, value, hash, shift + Node.Bits);
            if (status === "unchanged") {
                return Status.unchanged(this);
            }
            const sparse = Sparse.of(this._mask, replace(this._nodes, index, node));
            switch (status) {
                case "created":
                    return Status.created(sparse);
                case "updated":
                default:
                    return Status.updated(sparse);
            }
        }
        return Status.created(Sparse.of(set(this._mask, fragment), insert(this._nodes, index, Leaf.of(hash, key, value))));
    }
    delete(key, hash, shift) {
        const fragment = Node.fragment(hash, shift);
        if (test(this._mask, fragment)) {
            const index = Node.index(fragment, this._mask);
            const { result: node, status } = this._nodes[index].delete(key, hash, shift + Node.Bits);
            if (status === "unchanged") {
                return Status.unchanged(this);
            }
            if (node.isEmpty()) {
                const nodes = remove(this._nodes, index);
                if (nodes.length === 1) {
                    // We deleted the penultimate child of the Sparse, we may be able to
                    // simplify the tree.
                    if (nodes[0].isLeaf() || nodes[0] instanceof Collision) {
                        // The last child is leaf-like, hence hashes will be fully matched
                        // against its key(s) and we can remove the current Sparse
                        return Status.deleted(nodes[0]);
                    }
                    // Otherwise, the last child is a Sparse. We can't simply collapse the
                    // tree by removing the current Sparse, since it will cause the child
                    // mask to be tested with the wrong shift (its depth in the tree would
                    // be different).
                    // We could do some further optimisations (e.g., if the child's
                    // children are all leaf-like, we could instead delete the lone child
                    // and connect directly to the grandchildren). This is, however,
                    // getting hairy to make all cases working fine, and we assume this
                    // kind of situation is not too frequent. So we pay the price of
                    // keeping a non-branching Sparse until we need to optimise that.
                }
                return Status.deleted(Sparse.of(clear(this._mask, fragment), nodes));
            }
            return Status.deleted(Sparse.of(this._mask, replace(this._nodes, index, node)));
        }
        return Status.unchanged(this);
    }
    map(mapper) {
        return Sparse.of(this._mask, this._nodes.map((node) => node.map(mapper)));
    }
    equals(value) {
        return (value instanceof Sparse &&
            value._mask === this._mask &&
            value._nodes.length === this._nodes.length &&
            value._nodes.every((node, i) => node.equals(this._nodes[i])));
    }
    *[Symbol.iterator]() {
        for (const node of this._nodes) {
            yield* node;
        }
    }
}
function insert(array, index, value) {
    const result = new Array(array.length + 1);
    result[index] = value;
    for (let i = 0, n = index; i < n; i++) {
        result[i] = array[i];
    }
    for (let i = index, n = array.length; i < n; i++) {
        result[i + 1] = array[i];
    }
    return result;
}
function remove(array, index) {
    const result = new Array(array.length - 1);
    for (let i = 0, n = index; i < n; i++) {
        result[i] = array[i];
    }
    for (let i = index, n = result.length; i < n; i++) {
        result[i] = array[i + 1];
    }
    return result;
}
function replace(array, index, value) {
    const result = array.slice(0);
    result[index] = value;
    return result;
}
//# sourceMappingURL=node.js.map